unit dtUtils;

interface

uses dmDTData, vcl.ComCtrls, Math, System.Types, System.IOUtils,
  SysUtils, Windows, StrUtils, System.Classes, SCMDefines;

type TdtUtils = record
    private
      type
        PTime = ^TTime;
      var
        Splits: array[0..9] of TTime;
        TimeKeepers: array[0..2] of TTime;

      procedure ExtractHeader(const InputStr: string;
        ADTFileType: dtFileType;
        var Session: integer;
        var Event: integer;
        var Heat: integer;
        var Gender: string);

      procedure ExtractFooter(const InputStr: string;
        ADTFileType: dtFileType;
        var ACheckSum: string);

      procedure ExtractLane(const InputStr: string;
        ADTFileType: dtFileType;
        var lane: integer);
      procedure ExtractTimeKeepers(const InputStr: string;
        ADTFileType: dtFileType;
        ATimeKeepers: array of TTime);
      procedure ExtractSplits(const InputStr: string;
        ADTFileType: dtFileType;
        ASplits: array of TTime);

      function ConvertDTTimeToTime(const DTTimeStr: string): TTime;
//      function GetFileCreationTime(const FileName: TFileName): TDateTime;
      function GetFileNameSessionID(const AFileStr: string;
        ADTFileType: dtFileType): integer;
      function GetFileNameEventID(const AFileStr: string;
        ADTFileType: dtFileType): integer;
      function GetFileNameHeatID(const AFileStr: string;
        ADTFileType: dtFileType): integer;
      function GetFileNameGenderStr(const AFileStr: string;
        ADTFileType: dtFileType): string;
      function GetFileNameHashStr(const AFileStr: string;
        ADTFileType: dtFileType): string;
      // Main Process entry points
      procedure ProcessDirectory(const ADirectory: string; pBar: TProgressBar);
      // Sub-routines for Process
      procedure ProcessSession(FileName: TFileName; ADTFileType: dtFileType);
      procedure ProcessEvent(FileName: TFileName;
        SessionID: integer;
        ADTFileType: dtFileType);
      procedure ProcessHeat(sl: TStringList;
        EventID: integer;
        ADTFileType: dtFileType);
      procedure ProcessEntrant(sl: TStringList;
        DTHeatID: integer;
        ADTFileType: dtFileType);

      function StripAlphaChars(Inputstr: string): string;

    public

      procedure ExtractDTFile(const AFileName: TFileName;
        ADTFileType: dtFileType;
        var SessionID: integer;
        var EventID: integer;
        var HeatID: integer;
        var GenderStr: string;
        var HashStr: string);


      procedure PrepareDTData();
      procedure PopulateDTData(const ADirectory: string; pBar: TProgressBar);
      procedure AppendDTData(const AFileName:string);
      // procedure CalculateDeviation(INDIV_TEAM_ID: integer; AEventType: scmEventType);
      function GetDTFileTypeOfDirectory(const ADirectory: string): dtFileType;
      function GetDTFileTypeOfFile(const AFileName: string): dtFileType;

//      class operator Initialize (out Dest: TdtUtils);
//      class operator Finalize (var Dest: TdtUtils);

end;


// ---------------------------------------------------

{
This is a CSV file and can be hand typed or generated by meet management software.
Each line of this file should be formatted as follows:
Event Number,EventName,Number of Heats,Number of Splits,Round.
Example:
  1A,Boys 50 M Free,4,1,P
  1B,Girls 50 M Free,5,1,P
  2A,Boys 100 M Breaststroke,2,2,P
  2B,Girls 100 M Breaststroke,2,2,P
...
}

implementation

procedure TdtUtils.AppendDTData(const AFileName:string);
Begin
  // todo
End;

procedure TdtUtils.ProcessEntrant(sl: TStringList; DTHeatID: integer; ADTFileType: dtFileType);
var
  id, I, j, lane: integer;
  TimeFieldName, TimeModeFieldName,  TimeModeFieldNameErr, SplitFieldName: string;
begin
  // A record for each lane.
  // Ignore first (header) and last line (checkSum).
  for I := 1 to (sl.Count - 2) do
  begin
    id := DTData.tblDTEntrant.RecordCount + 1;
    DTData.tblDTEntrant.Append;

    ExtractLane(sl[I],ADTFileType, lane);
    ExtractTimeKeepers(sl[I], ADTFileType, TimeKeepers);

    {
    if EnabledSplits then
      ExtractSplits(sl[I], Splits);
    }

    DTData.tblDTEntrant.fieldbyName('INDVID').AsInteger := id; // primary key
    DTData.tblDTEntrant.fieldbyName('HeatID').AsInteger := DTHeatID; // master.detail.
    DTData.tblDTEntrant.fieldbyName('Lane').AsInteger := lane;

    for j := 0 to High(TimeKeepers) do
    begin
      // Generate field names
      TimeFieldName := Format('Time%d', [j + 1]);
      TimeModeFieldName := Format('Time%d', [j + 1]) + 'Mode';
      TimeModeFieldName := Format('Time%d', [j + 1]) + 'Err';
      // Set race-time and use flag based on TimeKeepers value
      if TimeKeepers[j] > 0 then
      begin
        DTData.tblDTEntrant.FieldByName(TimeFieldName).AsDateTime := TDateTime(TimeKeepers[j]);
        DTData.tblDTEntrant.FieldByName(TimeModeFieldName).AsInteger := Ord(tmAutoEnabled);
        DTData.tblDTEntrant.FieldByName(TimeModeFieldNameErr).Clear;
      end
      else
      begin
        DTData.tblDTEntrant.FieldByName(TimeFieldName).Clear;
        DTData.tblDTEntrant.FieldByName(TimeModeFieldName).AsInteger := Ord(tmAutoDisabled);
        DTData.tblDTEntrant.FieldByName(TimeModeFieldNameErr).AsInteger := Ord(tmeEmpty);
      end;
    end;

    {TODO -oBSA -cGeneral : Calculate deviation for each timekeeper?}

    DTData.tblDTEntrant.fieldbyName('imgPatch').AsInteger := 0;
    DTData.tblDTEntrant.fieldbyName('AutoTime').AsBoolean := true;

    // Split Times
    ExtractSplits(sl[i], ADTFileType, Splits);
    for j := 0 to High(Splits) do
    begin
      // Generate field names
      SplitFieldName := Format('Split%d', [j + 1]);
      if Splits[j] > 0 then
        DTData.tblDTEntrant.fieldbyName(SplitFieldName).AsDateTime := TDateTime(Splits[j])
       else
        DTData.tblDTEntrant.FieldByName(SplitFieldName).Clear;
    end;

    DTData.tblDTEntrant.Post;

  end;

end;

procedure TdtUtils.ProcessEvent(FileName: TFileName; SessionID: integer;
  ADTFileType: dtFileType);
var
  sl: TStringList;
  SessionNum, EventNum, HeatNum, id: integer;
  GenderStr, checkSum: string;
begin
  // read header and lane information (Racetimes x3).
  sl := TStringList.Create();
  sl.LoadFromFile(FileName);
  if not sl.IsEmpty then
  begin
    // first line represents SessionNum, EventNum, HeatNum, gender (A,B,X)
    // delimeter is ';'
    ExtractHeader(sl[0], ADTFileType, SessionNum, EventNum, HeatNum, GenderStr);
    // checksum is the last line
    ExtractFooter(sl[sl.Count - 1], ADTFileType, checkSum);
    // calculate the IDENTIFIER.
    id := DTData.tblDTEvent.RecordCount + 1;
    // NEW RECORD.
    DTData.tblDTEvent.Append;
    DTData.tblDTEvent.fieldbyName('EventID').AsInteger := id; // PK
    DTData.tblDTEvent.fieldbyName('SessionID').AsInteger := SessionID; // master - detail.
    DTData.tblDTEvent.fieldbyName('EventNum').AsInteger := HeatNum;
    DTData.tblDTEvent.fieldbyName('CreatedDT').AsDateTime := Now;
    DTData.tblDTEvent.fieldbyName('Caption').AsString := 'Event: ' + IntToStr(EventNum);
    DTData.tblDTEvent.fieldbyName('GenderStr').AsString := GenderStr;
    // CHECKSUM - last line of text - common
    DTData.tblDTEvent.Post;
    // LANES + TIMEKEEPERS 1-3 + SPLITS (upto 10).
    {TODO -oBSA -cGeneral : Heat can be TEAM or INDV event... }
    // if scmEventType = etINDV
    ProcessHeat(sl, id, ADTFileType);
    // else
    // GetDTTEAM(sl, id);
  end;
  sl.free;
end;

procedure TdtUtils.ProcessHeat(sl: TStringList; EventID: integer; ADTFileType: dtFileType);
var
  SessionNum, EventNum, HeatNum, id: integer;
  Gender, checksum: string;
begin
  // read header and lane information (Racetimes x3).
  if not sl.IsEmpty then
  begin
    // first line represents SessionNum, EventNum, HeatNum, gender (A,B,X)
    // delimeter is ';'
    ExtractHeader(sl[0], ADTFileType, SessionNum, EventNum, HeatNum, Gender);
    // checksum is the last line
    checksum := sl[sl.Count - 1];
    // calculate the IDENTIFIER.
    id := DTData.tblDTHeat.RecordCount + 1;
    // NEW RECORD.
    DTData.tblDTHeat.Append;
    DTData.tblDTHeat.fieldbyName('HeatID').AsInteger := id; // PK
    DTData.tblDTHeat.fieldbyName('EventID').AsInteger := EventID; // master - detail.
    // HEADER - first line of text - common
    DTData.tblDTHeat.fieldbyName('HeatNum').AsInteger := HeatNum;
    DTData.tblDTHeat.fieldbyName('Caption').AsString := 'Heat Number: ' + IntToStr(HeatNum);
    // CHECKSUM - last line of text - common
    DTData.tblDTHeat.fieldbyName('CheckSum').AsString := checksum;
    DTData.tblDTHeat.Post;
    // LANES + TIMEKEEPERS 1-3 + SPLITS (upto 10).
    {TODO -oBSA -cGeneral : Heat can be TEAM or INDV event... }
    // if scmEventType = etINDV
    ProcessEntrant(sl, id, ADTFileType);
    // else
    // GetDTTEAM(sl, id);
  end;
end;

procedure TdtUtils.ProcessSession(FileName: TFileName; ADTFileType: dtFileType);
var
  id, dtSessionID, dtEventNum, dtHeatNum: integer;
  HashStr, GenderStr: string;
  s: string;
  fCreationDT: TDateTime;
  fs: TFormatSettings;
begin
  id := DTData.tblDTSession.RecordCount + 1;
  // Get the creation time of the specified file
  fCreationDT := TFile.GetCreationTime(FileName);

  // Extract data fields from the Dolphin timing filename.
  ExtractDTFile(FileName, ADTFileType, dtSessionID, dtEventNum, dtHeatNum, GenderStr, Hashstr);
  DTData.tblDTSession.Append;
  DTData.tblDTSession.FieldByName('SessionID').AsInteger := id; // PK
  DTData.tblDTSession.fieldbyName('dtSessionID').AsInteger := dtSessionID;
  DTData.tblDTSession.fieldbyName('dtEventNum').AsInteger := dtEventNum;
  DTData.tblDTSession.fieldbyName('dtHeatNum').AsInteger := dtHeatNum;
  DTData.tblDTSession.fieldbyName('CreatedDT').AsDateTime := Now;
  DTData.tblDTSession.fieldbyName('Path').AsString := ExtractFilePath(FileName); // include file ext.
  DTData.tblDTSession.fieldbyName('FileName').AsString := ExtractFileName(FileName); // include file ext.
  DTData.tblDTSession.fieldbyName('SessionStart').AsDateTime := fCreationDT;
  // Create a session caption.
  fs := TFormatSettings.Create;
  fs.DateSeparator := '_';
  s := 'DT Session ID: ' + IntToStr(dtSessionID) + ' Date: ' + DatetoStr(fCreationDT, fs);
  DTData.tblDTSession.fieldbyName('Caption').AsString := s;
  // Filename also includes a hash number.
  DTData.tblDTSession.fieldbyName('HashStr').AsString := HashStr;
  // A sequential number for the Dolphin Timing session.
  if ADTFileType = dtDO4 then
    DTData.tblDTSession.fieldbyName('dtRaceID').AsInteger:= StrToIntDef(HashStr, 0);

  // FINALIZE - POST NEW RECORD.
  DTData.tblDTSession.Post;

  ProcessEvent(FileName, id, ADTFileType);
end;

function TdtUtils.StripAlphaChars(Inputstr: string): string;
begin

end;

{
function TdtUtils.GetFileCreationTime(const FileName: TFileName): TDateTime;
var
  Handle: THandle;
  FindData: TWin32FindData;
  SystemTime: TSystemTime;
  LocalFileTime: TFileTime;
begin
  Handle := FindFirstFile(PChar(FileName), FindData);
  if Handle <> INVALID_HANDLE_VALUE then
  begin
    Windows.FindClose(Handle);
    // Convert file time to local file time
    if FileTimeToLocalFileTime(FindData.ftCreationTime, LocalFileTime) then
    begin
      // Convert file time to system time
      if FileTimeToSystemTime(LocalFileTime, SystemTime) then
      begin
        // Convert system time to TDateTime
        Result := SystemTimeToDateTime(SystemTime);
        Exit;
      end;
    end;
  end;
  // Return 0 if there is an error
  Result := 0;
end;
}

procedure TdtUtils.ExtractHeader(const InputStr: string;
  ADTFileType: dtFileType;
  var Session: integer;
  var Event: integer;
  var Heat: integer;
  var Gender: string);
var
  Fields: TArray<string>;
begin
  // Split string by the ';' character
  // example 0;0;1;A  (DO3)
  // example 1;1;1;A (DO4)
  Session := 0;
  Event := 0;
  Heat := 0;
  Gender := 'X';

  Fields := SplitString(InputStr, ';');
  if Length(Fields) <> 4 then exit;   // return default assignment.
  Session := StrToIntDef(Fields[0], 0);
  Event := StrToIntDef(Fields[1], 0);
  Heat := StrToIntDef(Fields[2], 0);
  Gender := Fields[3];
end;

function TdtUtils.ConvertDTTimeToTime(const DTTimeStr: string): TTime;
var
  Seconds, Hundredths: integer;
  DotPos: integer;
  TimeValue: Double;
begin
  // Handle empty string (no time provided)
  if DTTimeStr = '' then
    Exit(0);

  // Find the position of the dot
  DotPos := Pos('.', DTTimeStr);

  if DotPos > 0 then
  begin
    // Convert the part before the dot (seconds)
    Seconds := StrToInt(Copy(DTTimeStr, 1, DotPos - 1));

    // Convert the part after the dot (hundredths)
    Hundredths := StrToInt(Copy(DTTimeStr, DotPos + 1, Length(DTTimeStr) - DotPos));

    // Calculate the time as a fraction of a day (TTime uses days)
    TimeValue := (Seconds + (Hundredths / 100)) / SecsPerDay;
    // SecsPerDay is 86400 (seconds in a day)
  end
  else
  begin
    // If there's no dot, treat the string as whole seconds
    Seconds := StrToInt(DTTimeStr);
    TimeValue := Seconds / SecsPerDay;
  end;

  Result := TimeValue;
end;

procedure TdtUtils.ExtractSplits(const InputStr: string;
  ADTFileType: dtFileType;
  ASplits: array of TTime);
var
  Fields: TArray<string>;
  i: Integer;
begin

{
Number of Splits – (1-10) Enter 1 to use the first time as the final time. A single length
race would have only one split (i.e. the final time), and multi length races would have
one split for every lap.
o Example 1: A 25 yard race in a 25 yard pool would have a split count of 1
meaning only on one time is collected (i.e. the final time)
o Example 2: A 100 meter race in a 50 meter pool would also have a split count
of 1 (i.e: the final time of the single lap.)
o Example 3: A 200 yard race in a 25 yard pool would have a split count of 4.
}

  // Initialize timekeepers
  for i := Low(ASplits) to High(ASplits) do ASplits[i] := 0;

  // Only DO4 captures split data?
  if not (ADTFileType = dtDO4) then exit;

  // Split string by the ';' character
  Fields := InputStr.Split([';']);

  // Field[0] - lane number
  // Field[1] ... [3] - timekeepers data.
  // Fiels[4] - split data index
  // Extract split data.
  if Length(Fields) > 4 then
  begin
    for i := 4 to Length(Fields) - 1 do  // ignore Fields[0] = lane number.
    begin
      if Length(Fields[i]) > 0 then
      begin
        if i <= High(ASplits) then // trap array index overrun
          ASplits[i] := ConvertDTTimeToTime(Fields[i])
      end;
    end;
  end;

end;

procedure TdtUtils.ExtractLane(const InputStr: string;
  ADTFileType: dtFileType;
  var lane: integer);
var
  Fields: TArray<string>;
  s: string;
begin
  lane := 0;
  // Split string by the ';' character
  Fields := SplitString(InputStr, ';');
  if Length(Fields) = 0 then exit;   // Input string is empty - err.
  // examples.
  // DO4 - 'Lane1;55.98;;'
  // DO3 - '1;95.25;;'
  s := StripAlphaChars(Fields[0]);
  if Length(s) > 0 then
    lane := StrToIntDef(s, 0); // Extract the lane as an integer
end;

procedure TdtUtils.ExtractTimeKeepers(const InputStr: string;
  ADTFileType: dtFileType;
  ATimeKeepers: array of TTime);
var
  Fields: TArray<string>;
  i: integer;
begin
  // Split string by the ';' character
  Fields := SplitString(InputStr, ';');

  // Note: Dolphin Timing allows for three timekeepers.
  // Fields[0] = lane number.
  // Fields[1], Fields[2], Fields[3] - TimeKeepers data in DTTime format.
  // examples.
  // DO4 - 'Lane1;55.98;;'
  // DO3 - '1;95.25;;'

  // Initialize timekeepers
  for i := Low(ATimeKeepers) to High(ATimeKeepers) do ATimeKeepers[i] := 0;

  // Extract timekeepers data.
  if Length(Fields) > 1 then
  begin
    for i := 1 to Length(Fields) - 1 do  // ignore Fields[0] = lane number.
    begin
      if Length(Fields[i]) > 0 then
      begin
        if i <= High(ATimeKeepers) then // trap array index overrun
          ATimeKeepers[i] := ConvertDTTimeToTime(Fields[i])
      end;
    end;
  end;
end;

procedure TdtUtils.ExtractDTFile(const AFileName: TFileName;
  ADTFileType: dtFileType; var SessionID, EventID, HeatID: integer; var GenderStr,
  HashStr: string);
var
  AFileStr: string;
begin
  AFileStr := ExtractFileName(AFileName);
  SessionID := GetFileNameSessionID(AFileStr, ADTFileType);
  EventID := GetFileNameEventID(AFileStr, ADTFileType);
  HeatID := GetFileNameHeatID(AFileStr, ADTFileType);
  GenderStr := GetFileNameGenderStr(AFileName, ADTFileType);
  HashStr := GetFileNameHashStr(AFileName, ADTFileType);

end;

procedure TdtUtils.ExtractFooter(const InputStr: string;
  ADTFileType: dtFileType; var ACheckSum: string);
begin
  case ADTFileType of
    dtDO4, dtDO3:
    begin
      // checksum is the last line
      // 16 characters
      if Length(InputStr) = 16 then
        ACheckSum := InputStr
      else
        ACheckSum := '';
    end;
    dtUnknown, dtALL: ACheckSum := '';
  end;
end;

function TdtUtils.GetFileNameEventID(const AFileStr: string;
        ADTFileType: dtFileType): integer;
var
  Fields: TArray<string>;
begin
  result := 0;
  // Split string by the '-' character
  Fields := SplitString(AFileStr, '-');
  if Length(Fields) > 2 then
    // Extract the first field - SessionID
    result := StrToIntDef(Fields[1], 0);
end;

function TdtUtils.GetFileNameGenderStr(const AFileStr: string;
  ADTFileType: dtFileType): string;
var
  GenderStr: string;
  Fields: TArray<string>;
begin
  result := '';
  GenderStr := '';
    // Split string by the '-' character
    Fields := SplitString(AFileStr, '-');
  // The third field has A or B or X appended at end of string.
  // Copy uses one-based array indexing.
  // A = boys, B = girls, X = mixed gender...
  if (ADTFileType = dtDO4) then
  begin
    if Length(Fields) > 3 then
    begin
      GenderStr := RightStr(Fields[2], 1);
      if (GenderStr <> 'A') and (GenderStr <> 'B') then GenderStr := 'X';
    end;
  end;
  if Length(GenderStr)>0 then
    result := GenderStr;
end;

function TdtUtils.GetFileNameHashStr(const AFileStr: string;
  ADTFileType: dtFileType): string;
var
  HashStr: string;
  Fields: TArray<string>;
begin
  result := '';
  HashStr := '';
  // Split string by the '-' character
  Fields := SplitString(AFileStr, '-');
  case ADTFileType of
    dtUnknown: ;
    dtDO4:
      begin
        if Length(Fields) > 4 then
        begin
          // The fourthfield has a '.' delimiter for the string and the '.do4' part
          HashStr := Copy(Fields[3], 1, Pos('.', Fields[3]) - 1);
        end;
      end;
    dtDO3:
      begin
        if Length(Fields) > 3 then
        begin
          // The third field has a '.' delimiter for the string and the '.do3' part
          HashStr := Copy(Fields[2], 1, Pos('.', Fields[2]) - 1);
        end;
      end;
    dtALL: ;
  end;
  if Length(HashStr) > 0 then
    result := HashStr;
end;

function TdtUtils.GetFileNameHeatID(const AFileStr: string;
        ADTFileType: dtFileType): integer;
var
  Fields: TArray<string>;
  s: string;
begin
  result := 0;
  if (ADTFileType = dtDO4) then
  begin
    // Split string by the '-' character
    Fields := SplitString(AFileStr, '-');
    if Length(Fields) > 3 then
    begin
      s := StripAlphaChars(Fields[2]);
      // Extract the first field - SessionID
      result := StrToIntDef(Fields[2], 0);
    end;
  end;
end;

function TdtUtils.GetFileNameSessionID(const AFileStr: string;
        ADTFileType: dtFileType): integer;
var
  Fields: TArray<string>;
begin
  result := 0;
  // Split string by the '-' character
  Fields := SplitString(AFileStr, '-');
  if Length(Fields) > 1 then
    // Extract the first field - SessionID
    result := StrToIntDef(Fields[0], 0);
end;

procedure TdtUtils.ProcessDirectory(const ADirectory: string; pBar: TProgressBar);
var
  LList, LListDO3, LListDO4: TStringDynArray;
  LSearchOption: TSearchOption;
  I: integer;
  ft: dtFileType;
begin
{
NOTE: The pattern '*.DO?' will match any file with a .DO extension followed
by any single character. This means it will match *.DO3, *.DO4, *.DO5, etc.
.. but to future proof the following method was chosen.
}
  if Assigned(pBar) then pBar.Position := 0;
  { Select the search option }
  // do not do recursive extract into subfolders
  LSearchOption := TSearchOption.soTopDirectoryOnly;
  try
    { For files use GetFiles method }
    LListDO3 := TDirectory.GetFiles(ADirectory, '*.DO3', LSearchOption);
    LListDO4 := TDirectory.GetFiles(ADirectory, '*.DO4', LSearchOption);

    { Combine the lists }
    SetLength(LList, Length(LListDO3) + Length(LListDO4));
    if Length(LListDO3) > 0 then
      Move(LListDO3[0], LList[0], Length(LListDO3) * SizeOf(string));
    if Length(LListDO4) > 0 then
      Move(LListDO4[0], LList[Length(LListDO3)], Length(LListDO4) * SizeOf(string));

    { Extract DATA and Populate the memory table. }
    for I := 0 to Length(LList) - 1 do
    begin
      ft := GetDTFileTypeOfFile(LList[I]);
      ProcessSession(LList[I], ft);
      // update progress bar.
      if Assigned(pBar) then
      begin
        pBar.Position := Trunc(Ceil((I + 1) / Length(LList) * 100));
        pBar.RePaint;
      end;
    end;
  except
    { Catch the possible exceptions }
    MessageBox(0, PChar('Incorrect path or search mask'),
      PChar('Extract Dolphin .DO3 and .DO4 Files'), MB_ICONERROR or MB_OK);
  end;
end;

procedure TdtUtils.PrepareDTData();
begin
  // clear all data records ....
  DTData.tblDTSession.EmptyDataSet;
  DTData.tblDTHeat.EmptyDataSet;
  DTData.tblDTEntrant.EmptyDataSet;
  DTData.tblDTNoodle.EmptyDataSet;

  // re-establish Master Detail ...
  DTData.tblDTEvent.MasterSource := DTData.dsDTSession;
  DTData.tblDTEvent.MasterFields := 'SessionID';
  DTData.tblDTEvent.DetailFields := 'SessionID';
  DTData.tblDTEvent.IndexFieldNames := 'SessionID';

  DTData.tblDTHeat.MasterSource := DTData.dsDTEvent;
  DTData.tblDTHeat.MasterFields := 'EventID';
  DTData.tblDTHeat.DetailFields := 'EventID';
  DTData.tblDTHeat.IndexFieldNames := 'EventID';

  DTData.tblDTEntrant.MasterSource := DTData.dsHeat;
  DTData.tblDTEntrant.MasterFields := 'HeatID';
  DTData.tblDTEntrant.DetailFields := 'HeatID';
  DTData.tblDTEntrant.IndexFieldNames := 'HeatID';

  DTData.tblDTNoodle.MasterSource := DTData.dsDTHeat;
  DTData.tblDTNoodle.MasterFields := 'HeatID';
  DTData.tblDTNoodle.DetailFields := 'HeatID';
  DTData.tblDTNoodle.IndexFieldNames := 'HeatID';

end;

Procedure TdtUtils.PopulateDTData(const ADirectory: string; pBar: TProgressBar);
begin
  DTData.tblDTSession.DisableControls;
  DTData.tblDTEvent.DisableControls;
  DTData.tblDTHeat.DisableControls;
  DTData.tblDTEntrant.DisableControls;
  DTData.tblDTNoodle.DisableControls;

  if Assigned(pBar) then pBar.Position := 0;

  ProcessDirectory(ADirectory, pBar);

  DTData.tblDTSession.First;
  DTData.tblDTSession.EnableControls;
  DTData.tblDTEvent.EnableControls;
  DTData.tblDTHeat.EnableControls;
  DTData.tblDTEntrant.EnableControls;
  DTData.tblDTNoodle.EnableControls;

  end;

function TdtUtils.GetDTFileTypeOfDirectory(const ADirectory: string): dtFileType;
var
  LList: TStringDynArray;
  LSearchOption: TSearchOption;
  fileMask, fn: string;
  I, countDO3, countDO4: integer;
  ft: dtFileType;
begin
  fileMask := '*.DO?';
  countDO3 := 0;
  countDO4 := 0;
  result := dtUnknown;
  // do not do recursive extract into subfolders
  LSearchOption := TSearchOption.soTopDirectoryOnly;
  try
    { For files use GetFiles method }
    LList := TDirectory.GetFiles(ADirectory, fileMask, LSearchOption);
    for I := 0 to Length(LList) - 1 do
    begin
      fn := ExtractFileName(LList[I]); // avoid mask match in directory part.
      ft := GetDTFileTypeOfFile(fn);
      if ft = dtFileType.dtDO3 then Inc(countDO3);
      if ft = dtFileType.dtDO4 then Inc(countDO4);
    end;
  except
    { Catch the possible exceptions }
    MessageBox(0, PChar('Incorrect path or search mask'),
      PChar('Get file type of directory...'), MB_ICONERROR or MB_OK);
    exit;
  end;
  if (countDO3 > 0) and (countDO4 = 0) then
    result := dtDO3
  else if (countDO3 = 0) and (countDO4 > 0) then
    result := dtDO4
  else
    result := dtALL;
  end;

function TdtUtils.GetDTFileTypeOfFile(const AFileName: string): dtFileType;
begin
  result := dtUnknown;
  if AfileName.Contains('.DO3') then
    result := dtDO3
  else if AfileName.Contains('.DO4') then
    result := dtDO4;
end;

end.

