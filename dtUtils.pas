unit dtUtils;

interface

uses dmDTData, vcl.ComCtrls, Math;

function GetFileCreationTime(const FileName: string): TDateTime;

// GENERIC ...
procedure ExtractHeaderFields(const InputStr:
  string; var Session: integer;
  var Event: integer;
  var Heat: integer;
  var Gender: string);

// DO3 ...
procedure ExtractTextFieldsDO3(const InputStr: string;
  var lane: integer;
  var Time1: TTime;
  var Time2: TTime;
  var Time3: TTime);

procedure ExtractDataDO3Files(const ADirectory: string; pBar: TProgressBar);
procedure ExtractFileNameFieldsDO3(const InputStr: string;
  var Session: integer;
  var Event: integer;
  var GUID: string);
// ---------------------------------------------------

// DO4 ...
procedure ExtractTextFieldsDO4(const InputStr: string;
  var lane: integer;
  var Time1: TTime;
  var Time2: TTime;
  var Time3: TTime);

procedure ExtractSplitsDO4(const InputStr: string;
  var Split1: TTime;
  var Split2: TTime;
  var Split3: TTime;
  var Split4: TTime;
  var Split5: TTime;
  var Split6: TTime);

procedure ExtractDataDO4Files(const ADirectory: string);

procedure ExtractFileNameFieldsDO4(const InputStr:
  string; var Session: integer;
  var Event: integer;
  var Heat: integer;
  var Gender:
  string; var
  RaceID: string);
// ---------------------------------------------------

procedure BuildCSVEventData(AFileName: string);
{
This is a CSV file and can be hand typed or generated by meet management software.
Each line of this file should be formatted as follows:
Event Number,EventName,Number of Heats,Number of Splits,Round.
Example:
  1A,Boys 50 M Free,4,1,P
  1B,Girls 50 M Free,5,1,P
  2A,Boys 100 M Breaststroke,2,2,P
  2B,Girls 100 M Breaststroke,2,2,P
...
}



implementation

uses
  SysUtils, Windows, System.IOUtils, System.Types,
  StrUtils, System.Classes;

procedure BuildCSVEventData(AFileName: string);
var
  sl: TStringList;
  s, s2, s3: string;
  i, id: integer;
begin
  sl := TStringlist.Create;
//  DTData.qryEvent.DisableControls;
  DTData.qryEvent.First();
  while not DTData.qryEvent.Eof do
  begin
    s := '';
    i := DTData.qryEvent.FieldByName('EventNum').AsInteger;
    s := s + IntToStr(i) + ', ';
    s2 := DTData.qryDistance.FieldByName('Caption').AsString + ' ' +
    DTData.qryStroke.FieldByName('Caption').AsString;
    s3 := DTData.qryEvent.FieldByName('Caption').AsString;
    if Length(s3) > 0 then
      s2 := s2 + ' ' + s3;
    s := s + s2 + ', ';
    // Get Number of Heats
    id := DTData.qryEvent.FieldByName('EventID').AsInteger;
    i := DTData.GetNumberOfHeats(id);
    s := s + IntToStr(i) + ', ';
    { TODO -oBSA : Implement Splits for Dolphin Timing }
    // Number of Splits - NOT AVAILABLE IN THIS VERSION.
    s := s + '0, ';
    { Round .... requires db v1.1.5.4.
    * P: Preliminary (DEFAULT)
    * Q: Quarterfinals
    * S: Semifinals
    * F: Finals
    }
    s := s + 'P';
    sl.Add(s);
    DTData.qryEvent.Next;
  end;
  DTData.qryEvent.First();
//  DTData.qryEvent.EnableControls;
  if not sl.IsEmpty then
    sl.SaveToFile(AFileName);
  sl.free;
end;

function GetFileCreationTime(const FileName: string): TDateTime;
var
  Handle: THandle;
  FindData: TWin32FindData;
  SystemTime: TSystemTime;
  LocalFileTime: TFileTime;
begin
  Handle := FindFirstFile(PChar(FileName), FindData);
  if Handle <> INVALID_HANDLE_VALUE then
  begin
    Windows.FindClose(Handle);
    // Convert file time to local file time
    if FileTimeToLocalFileTime(FindData.ftCreationTime, LocalFileTime) then
    begin
      // Convert file time to system time
      if FileTimeToSystemTime(LocalFileTime, SystemTime) then
      begin
        // Convert system time to TDateTime
        Result := SystemTimeToDateTime(SystemTime);
        Exit;
      end;
    end;
  end;
  // Return 0 if there is an error
  Result := 0;
end;

procedure ExtractHeaderFields(const InputStr: string; var Session: integer;
  var Event: integer; var Heat: integer; var Gender: string);
var
  Fields: TArray<string>;
begin
  // Split string by the ';' character
  // example 0;0;1;A  (DO3)
  // example 1;1;1;A (DO4)
  Fields := SplitString(InputStr, ';');
  if Length(Fields) <> 4 then
    raise Exception.Create('Invalid format');
  Session := StrToInt(Fields[0]);
  Event := StrToInt(Fields[1]);
  Heat := StrToInt(Fields[2]);
  Gender := Fields[3];
end;

function StrToCustomTime(const TimeStr: string): TTime;
var
  Seconds, Hundredths: integer;
  DotPos: integer;
  TimeValue: Double;
begin
  // Handle empty string (no time provided)
  if TimeStr = '' then
    Exit(0);

  // Find the position of the dot
  DotPos := Pos('.', TimeStr);

  if DotPos > 0 then
  begin
    // Convert the part before the dot (seconds)
    Seconds := StrToInt(Copy(TimeStr, 1, DotPos - 1));

    // Convert the part after the dot (hundredths)
    Hundredths := StrToInt(Copy(TimeStr, DotPos + 1, Length(TimeStr) - DotPos));

    // Calculate the time as a fraction of a day (TTime uses days)
    TimeValue := (Seconds + (Hundredths / 100)) / SecsPerDay;
    // SecsPerDay is 86400 (seconds in a day)
  end
  else
  begin
    // If there's no dot, treat the string as whole seconds
    Seconds := StrToInt(TimeStr);
    TimeValue := Seconds / SecsPerDay;
  end;

  Result := TimeValue;
end;

procedure ExtractTextFieldsDO4(const InputStr: string;
  var lane: integer;
  var Time1: TTime;
  var Time2: TTime;
  var Time3: TTime);
var
  Fields: TArray<string>;
  tempStr: string;
  I: integer;
begin
  // Split string by the ';' character
  Fields := SplitString(InputStr, ';');
  if Length(Fields) < 2 then
    raise Exception.Create('Invalid format');

  TempStr := '';
  // Loop through each character in Fields[0] and extract only digits
  for I := 1 to Length(Fields[0]) do
    if CharInSet(Fields[0][I], ['0'..'9']) then
      TempStr := TempStr + Fields[0][I];

  // Extract the lane as an integer
  lane := StrToIntDef(TempStr, -1);

  // Convert time fields using the custom function
  Time1 := StrToCustomTime(Fields[1]);

  // Handle optional time fields (Time2 and Time3)
  if Length(Fields) > 2 then
    Time2 := StrToCustomTime(Fields[2])
  else
    Time2 := 0; // No Time2 provided

  if Length(Fields) > 3 then
    Time3 := StrToCustomTime(Fields[3])
  else
    Time3 := 0; // No Time3 provided  end;
end;

procedure ExtractSplitsDO4(const InputStr: string;
  var Split1: TTime;
  var Split2: TTime;
  var Split3: TTime;
  var Split4: TTime;
  var Split5: TTime;
  var Split6: TTime);
begin

end;

procedure ExtractTextFieldsDO3(const InputStr: string; var lane: integer;
  var Time1: TTime; var Time2: TTime; var Time3: TTime);
var
  Fields: TArray<string>;
begin
  // Split string by the ';' character
  Fields := SplitString(InputStr, ';');
  if Length(Fields) < 2 then
    raise Exception.Create('Invalid format');

  // Extract the lane as an integer
  lane := StrToInt(Fields[0]);

  // Convert time fields using the custom function
  Time1 := StrToCustomTime(Fields[1]);

  // Handle optional time fields (Time2 and Time3)
  if Length(Fields) > 2 then
    Time2 := StrToCustomTime(Fields[2])
  else
    Time2 := 0; // No Time2 provided

  if Length(Fields) > 3 then
    Time3 := StrToCustomTime(Fields[3])
  else
    Time3 := 0; // No Time3 provided
end;

procedure ExtractFileNameFieldsDO3(const InputStr: string; var Session: integer;
  var Event: integer; var GUID: string);
var
  Fields: TArray<string>;
begin
  // Split string by the '-' character
  Fields := SplitString(InputStr, '-');
  if Length(Fields) <> 3 then
    raise Exception.Create('Invalid format');
  // Extract the first and second fields as integers
  Session := StrToInt(Fields[0]);
  Event := StrToInt(Fields[1]);
  // The third field has a '.' delimiter for the string and the '.do3' part
  GUID := Copy(Fields[2], 1, Pos('.', Fields[2]) - 1);
  // Check the '.do3' part
  {
    if Fields[2].Substring(Pos('.', Fields[2])) = '.do3' then
    FinalFieldInt := 1
    else
    raise Exception.Create('Invalid final part');
  }
end;

procedure ExtractFileNameFieldsDO4(const InputStr: string;
  var Session: integer;
  var Event: integer;
  var Heat: integer;
  var Gender: string;
  var RaceID: string);
var
  Fields: TArray<string>;
  s: string;
begin
  // Split string by the '-' character
  Fields := SplitString(InputStr, '-');
  if Length(Fields) <> 4 then
    raise Exception.Create('Invalid format');
  // Extract the first and second fields as integers
  Session := StrToInt(Fields[0]);
  Event := StrToInt(Fields[1]);
  // The third field has A or B or X appended at end of string.
  // Copy uses one-based array indexing.
  // A = boys, B = girls, X = mixed gender...
  Gender := RightStr(Fields[2], 1);
  if (Gender <> 'A') or (Gender <> 'B') then
    Gender := 'X';
  s := Copy(Fields[2], 1, Length(Fields[2]) - 1);
  Heat := StrToIntDef(s, 0);
  // The fourthfield has a '.' delimiter for the string and the '.do4' part
  RaceID := Copy(Fields[3], 1, Pos('.', Fields[2]) - 1);
end;

procedure ExtractDataDO4Files(const ADirectory: string);
var
  LList: TStringDynArray;
  I, J: integer;
  LSearchOption: TSearchOption;
  fileMask, fn, fn2: string;
  // filename params
  fCreationDT: TDateTime;
  fSessionNum, fEventNum, fHeatNum, newDTID, newDTHeatID: integer;
  // NOTE: fGender is available in DO4 only.
  // NOTE: GUID in DO4 can be converted to integer.
  fGender, fGUID: string;
  // fileheader params
  Session, Event, Heat: integer;
  Gender: string;
  // filebody params
  lane: integer;
  Time1, Time2, Time3: TTime;
  // Split data DO4 only.
  Split1, Split2, Split3, Split4, Split5: TTime;
  Split6, Split7, Split8, Split9, Split10: TTime;

  sl: TStringList;
  checksum: string;
begin
  fileMask := '*.DO4';
  { Select the search option }
  // do not do recursive extract into subfolders
  LSearchOption := TSearchOption.soTopDirectoryOnly;
  try
    { For files use GetFiles method }
    LList := TDirectory.GetFiles(ADirectory, fileMask, LSearchOption);
  except
    { Catch the possible exceptions }
    MessageBox(0, PChar('Incorrect path or search mask'),
      PChar('Extract Dolphin .DO4 Files'), MB_ICONERROR or MB_OK);
    Exit;
  end;
  // clear all data records ....
  DTData.tblDT.EmptyDataSet;
  { Extract DATA and Populate the memory table. }
  for I := 0 to Length(LList) - 1 do
  begin
    fn := LList[I];
    fn2 := ExtractFileName(fn);   // includes file extension
    // Get the creation time of the specified file
    fCreationDT := TFile.GetCreationTime(fn);
    // Filename used can show session, event. (After correct DT setup).
    // fGUID is unique string(do3)/number(do4) given to each file by DT.
    ExtractFileNameFieldsDO4(fn, fSessionNum, fEventNum, fHeatNum, fGender,
      fGUID);

    // write out DTData.tblDT record
    // CREATE NEW RECORD - one for each lane.
    DTData.tblDT.Append;
    // FILENAME = INFORMATION (prefix f)  common
    DTData.tblDT.fieldbyName('CreatedDT').AsDateTime := fCreationDT;
    DTData.tblDT.fieldbyName('FileName').AsString := fn2; // include file ext.
    DTData.tblDT.fieldbyName('fSession').AsInteger := fSessionNum;
    DTData.tblDT.fieldbyName('fEvent').AsInteger := fEventNum;
    DTData.tblDT.fieldbyName('fHeat').AsInteger:= fHeatNum; // DO4 only.
    DTData.tblDT.fieldbyName('fGender').AsString := fGender; // DO4 only.
    DTData.tblDT.fieldbyName('fGUID').AsString := fGUID;
    // FINALIZE - POST NEW RECORD.
    DTData.tblDT.Post;

    newDTID := DTData.tblDT.fieldbyName('DTID').AsInteger;

    // read header and lane information (Racetimes x3).
    sl := TStringList.Create();
    sl.LoadFromFile(fn);
    if not sl.IsEmpty then
    begin

      // clear all data records ....
      DTData.tblDTHeat.EmptyDataSet;

      // first line represents session, event, heat, gender (A,B,X)
      // delimeter is ';'
      ExtractHeaderFields(sl[0], Session, Event, Heat, Gender);
      // checksum is the last line
      checksum := sl[sl.Count - 1];
      DTData.tblDTHeat.Append;
      DTData.tblDTHeat.fieldbyName('DTID').AsInteger := newDTID; // master - detail.
      // HEADER - first line of text - common
      DTData.tblDTHeat.fieldbyName('Session').AsInteger := Session;
      DTData.tblDTHeat.fieldbyName('Event').AsInteger := Event;
      DTData.tblDTHeat.fieldbyName('Heat').AsInteger := Heat;
      DTData.tblDTHeat.fieldbyName('Gender').AsString := Gender;
      // CHECKSUM - last line of text - common
      DTData.tblDTHeat.fieldbyName('CheckSum').AsString := checksum;
      DTData.tblDTHeat.Post;
      newDTHeatID := DTData.tblDTHeat.fieldbyName('DTHeatID').AsInteger;

      // clear all data records ....
      DTData.tblDTLane.EmptyDataSet;

      // A record for each lane.
      //Ignore first (header) and last line (checkSum).
      for J := 1 to (sl.Count - 2) do
      begin
        // CREATE NEW RECORD - one for each lane.
        DTData.tblDTLane.Append;

        ExtractTextFieldsDO4(sl[J], lane, Time1, Time2, Time3);
        ExtractSplitsDO4(sl[J], Split1, Split2, Split3, Split4, Split5, Split6);
        DTData.tblDTLane.fieldbyName('DTHeatID').AsInteger := newDTHeatID; // master - detail.
        DTData.tblDTLane.fieldbyName('Lane').AsInteger := lane;

        if (Time1 > 0) then
          DTData.tblDTLane.fieldbyName('Time1').AsDateTime := TDateTime(Time1)
        else
          DTData.tblDTLane.fieldbyName('Time1').Clear;

        if (Time2 > 0) then
          DTData.tblDTLane.fieldbyName('Time2').AsDateTime := TDateTime(Time2)
        else
          DTData.tblDTLane.fieldbyName('Time2').Clear;

        if (Time3 > 0) then
          DTData.tblDTLane.fieldbyName('Time3').AsDateTime := TDateTime(Time3)
        else
          DTData.tblDTLane.fieldbyName('Time3').Clear;

        DTData.tblDTLane.fieldbyName('AutoTime').AsBoolean := true;
        if (Time1 > 0) then
          DTData.tblDTLane.fieldbyName('UseTime1').AsBoolean := true else
          DTData.tblDTLane.fieldbyName('UseTime1').AsBoolean := false;
        if (Time2 > 0) then
          DTData.tblDTLane.fieldbyName('UseTime2').AsBoolean := true else
          DTData.tblDTLane.fieldbyName('UseTime2').AsBoolean := false;
        if (Time3 > 0) then
          DTData.tblDTLane.fieldbyName('UseTime3').AsBoolean := true else
          DTData.tblDTLane.fieldbyName('UseTime3').AsBoolean := false;
        // DO4 only....
        DTData.tblDTLane.fieldbyName('Split1').Clear;
        DTData.tblDTLane.fieldbyName('Split2').Clear;
        DTData.tblDTLane.fieldbyName('Split3').Clear;
        DTData.tblDTLane.fieldbyName('Split4').Clear;
        DTData.tblDTLane.fieldbyName('Split5').Clear;
        DTData.tblDTLane.fieldbyName('Split6').Clear;
        DTData.tblDTLane.fieldbyName('Split7').Clear;
        DTData.tblDTLane.fieldbyName('Split8').Clear;
        DTData.tblDTLane.fieldbyName('Split9').Clear;
        DTData.tblDTLane.fieldbyName('Split10').Clear;
        DTData.tblDTLane.Post;
      end;
    end;
    sl.Free;
  end;
end;

procedure ExtractDataDO3Files(const ADirectory: string; pBar: TProgressBar);
var
  LList: TStringDynArray;
  I, J: integer;
  LSearchOption: TSearchOption;
  fileMask, fn, fn2: string;
  // filename params
  fCreationDT: TDateTime;
  fSessionNum, fEventNum, newDTID, newDTHeatID: integer;
  fGUID: string;
  // fileheader params
  Session, Event, Heat: integer;
  Gender: string;
  // filebody params
  lane: integer;
  Time1, Time2, Time3: TTime;
  sl: TStringList;
  checksum: string;
begin
  fileMask := '*.DO3';
  if Assigned(pBar) then pBar.Position := 0;
  { Select the search option }
  // do not do recursive extract into subfolders
  LSearchOption := TSearchOption.soTopDirectoryOnly;
  try
    { For files use GetFiles method }
    LList := TDirectory.GetFiles(ADirectory, fileMask, LSearchOption);
  except
    { Catch the possible exceptions }
    MessageBox(0, PChar('Incorrect path or search mask'),
      PChar('Extract Dolphin .DO3 Files'), MB_ICONERROR or MB_OK);
    Exit;
  end;
  // clear all data records ....
  DTData.tblDT.EmptyDataSet;

  pBar.Position := 0;

  { Extract DATA and Populate the memory table. }
  for I := 0 to Length(LList) - 1 do
  begin
    fn := LList[I];
    fn2 := ExtractFileName(fn);   // includes file extension
    // Get the creation time of the specified file
    fCreationDT := TFile.GetCreationTime(fn);
    // Filename used can show session, event. (After correct DT setup).
    // fGUID is unique string(do3)/number(do4) given to each file by DT.
    ExtractFileNameFieldsDO3(fn2, fSessionNum, fEventNum, fGUID);
    // write out DTData.tblDT record
    // CREATE NEW RECORD - one for each lane.
    DTData.tblDT.Append;
    // FILENAME = INFORMATION (prefix f)  common
    DTData.tblDT.fieldbyName('CreatedDT').AsDateTime := fCreationDT;
    DTData.tblDT.fieldbyName('FileName').AsString := fn2; // include file ext.
    DTData.tblDT.fieldbyName('fSession').AsInteger := fSessionNum;
    DTData.tblDT.fieldbyName('fEvent').AsInteger := fEventNum;
    // DTData.tblDT.fieldbyName('fHeat').AsInteger:= fHeatNum; // DO4 only.
    // DTData.tblDT.fieldbyName('fGender').AsString := fGender; // DO4 only.
    DTData.tblDT.fieldbyName('fGUID').AsString := fGUID;
    // FINALIZE - POST NEW RECORD.
    DTData.tblDT.Post;

    newDTID := DTData.tblDT.fieldbyName('DTID').AsInteger;

    // read header and lane information (Racetimes x3).
    sl := TStringList.Create();
    sl.LoadFromFile(fn);
    if not sl.IsEmpty then
    begin

      // clear all data records ....
      DTData.tblDTHeat.EmptyDataSet;

      // first line represents session, event, heat, gender (A,B,X)
      // delimeter is ';'
      ExtractHeaderFields(sl[0], Session, Event, Heat, Gender);
      // checksum is the last line
      checksum := sl[sl.Count - 1];
      DTData.tblDTHeat.Append;
      DTData.tblDTHeat.fieldbyName('DTID').AsInteger := newDTID; // master - detail.
      // HEADER - first line of text - common
      DTData.tblDTHeat.fieldbyName('Session').AsInteger := Session;
      DTData.tblDTHeat.fieldbyName('Event').AsInteger := Event;
      DTData.tblDTHeat.fieldbyName('Heat').AsInteger := Heat;
      DTData.tblDTHeat.fieldbyName('Gender').AsString := Gender;
      // CHECKSUM - last line of text - common
      DTData.tblDTHeat.fieldbyName('CheckSum').AsString := checksum;
      DTData.tblDTHeat.Post;
      newDTHeatID := DTData.tblDTHeat.fieldbyName('DTHeatID').AsInteger;

      // clear all data records ....
      DTData.tblDTLane.EmptyDataSet;

       // A record for each lane.
       // Ignore first (header) and last line (checkSum).
      for J := 1 to (sl.Count - 2) do
      begin


        DTData.tblDTLane.Append;
        ExtractTextFieldsDO3(sl[J], lane, Time1, Time2, Time3);
        DTData.tblDTLane.fieldbyName('DTHeatID').AsInteger := newDTHeatID; // master - detail.
        DTData.tblDTLane.fieldbyName('Lane').AsInteger := lane;

        if (Time1 > 0) then
          DTData.tblDTLane.fieldbyName('Time1').AsDateTime := TDateTime(Time1)
        else
          DTData.tblDTLane.fieldbyName('Time1').Clear;

        if (Time2 > 0) then
          DTData.tblDTLane.fieldbyName('Time2').AsDateTime := TDateTime(Time2)
        else
          DTData.tblDTLane.fieldbyName('Time2').Clear;

        if (Time3 > 0) then
          DTData.tblDTLane.fieldbyName('Time3').AsDateTime := TDateTime(Time3)
        else
          DTData.tblDTLane.fieldbyName('Time3').Clear;

        DTData.tblDTLane.fieldbyName('AutoTime').AsBoolean := true;
        if (Time1 > 0) then
          DTData.tblDTLane.fieldbyName('UseTime1').AsBoolean := true else
          DTData.tblDTLane.fieldbyName('UseTime1').AsBoolean := false;
        if (Time2 > 0) then
          DTData.tblDTLane.fieldbyName('UseTime2').AsBoolean := true else
          DTData.tblDTLane.fieldbyName('UseTime2').AsBoolean := false;
        if (Time3 > 0) then
          DTData.tblDTLane.fieldbyName('UseTime3').AsBoolean := true else
          DTData.tblDTLane.fieldbyName('UseTime3').AsBoolean := false;

        // DO4 only....
        DTData.tblDTLane.fieldbyName('Split1').Clear;
        DTData.tblDTLane.fieldbyName('Split2').Clear;
        DTData.tblDTLane.fieldbyName('Split3').Clear;
        DTData.tblDTLane.fieldbyName('Split4').Clear;
        DTData.tblDTLane.fieldbyName('Split5').Clear;
        DTData.tblDTLane.fieldbyName('Split6').Clear;
        DTData.tblDTLane.fieldbyName('Split7').Clear;
        DTData.tblDTLane.fieldbyName('Split8').Clear;
        DTData.tblDTLane.fieldbyName('Split9').Clear;
        DTData.tblDTLane.fieldbyName('Split10').Clear;
        DTData.tblDTLane.Post;

      end;


      pBar.Position := Trunc(Ceil(i / (Length(LList) - 1))   * 100);
      pBar.RePaint;

    end;
    sl.Free;
  end;
end;

end.

