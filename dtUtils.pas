unit dtUtils;

interface

uses dmDTData, vcl.ComCtrls, Math, System.Types, System.IOUtils,
  SysUtils, Windows, StrUtils, System.Classes, SCMDefines;

function ConvertDTTimeToTime(const DTTimeStr: string): TTime;
function StripAlphaChars(InputStr: string): string;


type TdtLane = record
  public
    var
    Lane: integer;
    TimeKeepers: array[0..2] of TTime;
    Splits: array[0..9] of TTime;
    function ExtractLane(InputStr: string): boolean; overload;
    function ExtractLane(sl: TStringList; LaneNum: integer): boolean; overload;
end;

type TdtUtils = record
    private
      type
        PTime = ^TTime;
      var
        Splits: array[0..9] of TTime;
        TimeKeepers: array[0..2] of TTime;
        fPrecedence: dtPrecedence;
        fStrList: TStringList;

//      function ExtractHeaderSessionNum(sl: TStringList): integer;
//      function ExtractHeaderEventNum(sl: TStringList): integer;
//      function ExtractHeaderHeatNum(sl: TStringList): integer;
//      function ExtractHeaderGenderChar(sl: TStringList): char;
//      function ExtractFooterHashStr(sl: TStringList): string;


      function ExtractSessionNum(const AFileName: TFileName;
        ADTFileType: dtFileType): integer;

      function ExtractEventNum(const AFileName: TFileName;
        ADTFileType: dtFileType): integer;

      function ExtractHashStr(const AFileName: TFileName;
        ADTFileType: dtFileType): string;

      procedure ExtractHeader(const InputStr: string;
        ADTFileType: dtFileType;
        var Session: integer;
        var Event: integer;
        var Heat: integer;
        var Gender: string);

      procedure ExtractFooter(const InputStr: string;
        ADTFileType: dtFileType;
        var ACheckSum: string);

      procedure ExtractLane(const InputStr: string;
        ADTFileType: dtFileType;
        var lane: integer);

      procedure ExtractTimeKeepers(const InputStr: string;
        ADTFileType: dtFileType;
        ATimeKeepers: array of TTime);

      procedure ExtractSplits(const InputStr: string;
        ADTFileType: dtFileType;
        ASplits: array of TTime);


      function GetFileNameSessionNum(const AFileStr: string;
        ADTFileType: dtFileType): integer;
      function GetFileNameEventNum(const AFileStr: string;
        ADTFileType: dtFileType): integer;
      function GetFileNameHeatNum(const AFileStr: string;
        ADTFileType: dtFileType): integer;
      function GetFileNameRoundStr(const AFileStr: string;
        ADTFileType: dtFileType): string;
      function GetFileNameHashStr(const AFileStr: string;
        ADTFileType: dtFileType): string;


      // Main Process entry points
      procedure ProcessDirectory(const ADirectory: string; pBar: TProgressBar);
      // Sub-routines for Process
      procedure ProcessSession(AFileName: TFileName; ADTFileType: dtFileType);
      procedure ProcessEvent(AFileName: TFileName;
        SessionID: integer;
        ADTFileType: dtFileType);
      procedure ProcessHeat(AFileName: TFileName;
        EventID: integer;
        ADTFileType: dtFileType);
      procedure ProcessEntrant(sl: TStringList;
        DTHeatID: integer;
        ADTFileType: dtFileType);


    public

      procedure ExtractDTFile(const AFileName: TFileName;
        ADTFileType: dtFileType;
        var SessionID: integer;
        var EventID: integer;
        var HeatID: integer;
        var RoundStr: string;
        var HashStr: string);


      procedure PrepareDTData();
      procedure PopulateDTData(const ADirectory: string; pBar: TProgressBar);
      procedure AppendDTData(const AFileName:string);
      // procedure CalculateDeviation(EntrantID: integer; AEventType: scmEventType);
      function GetDTFileTypeOfDirectory(const ADirectory: string): dtFileType;
      function GetDTFileTypeOfFile(const AFileName: string): dtFileType;

      class operator Initialize (out Dest: TdtUtils);
      class operator Finalize (var Dest: TdtUtils);

end;


// ---------------------------------------------------

{
This is a CSV file and can be hand typed or generated by meet management software.
Each line of this file should be formatted as follows:
Event Number,EventName,Number of Heats,Number of Splits,Round.
Example:
  1A,Boys 50 M Free,4,1,P
  1B,Girls 50 M Free,5,1,P
  2A,Boys 100 M Breaststroke,2,2,P
  2B,Girls 100 M Breaststroke,2,2,P
...
}

implementation


function StripAlphaChars(InputStr: string): string;
begin

end;


function ConvertDTTimeToTime(const DTTimeStr: string): TTime;
var
  Seconds, Hundredths: integer;
  DotPos: integer;
  TimeValue: Double;
begin
  // Handle empty string (no time provided)
  if DTTimeStr = '' then
    Exit(0);

  // Find the position of the dot
  DotPos := Pos('.', DTTimeStr);

  if DotPos > 0 then
  begin
    // Convert the part before the dot (seconds)
    Seconds := StrToInt(Copy(DTTimeStr, 1, DotPos - 1));

    // Convert the part after the dot (hundredths)
    Hundredths := StrToInt(Copy(DTTimeStr, DotPos + 1, Length(DTTimeStr) - DotPos));

    // Calculate the time as a fraction of a day (TTime uses days)
    TimeValue := (Seconds + (Hundredths / 100)) / SecsPerDay;
    // SecsPerDay is 86400 (seconds in a day)
  end
  else
  begin
    // If there's no dot, treat the string as whole seconds
    Seconds := StrToInt(DTTimeStr);
    TimeValue := Seconds / SecsPerDay;
  end;

  Result := TimeValue;
end;




procedure TdtUtils.AppendDTData(const AFileName:string);
var
 ft: dtFileType;
Begin
  // todo
  ft := GetDTFileTypeOfFile(AFileName);
  ProcessSession(AFileName, ft);
End;

procedure TdtUtils.ProcessEntrant(sl: TStringList; DTHeatID: integer; ADTFileType: dtFileType);
var
  id, I, j, lane: integer;
  TimeFieldName, TimeModeFieldName, TimeModeFieldNameErr, SplitFieldName, s: string;
begin
  // A record for each lane.
  // Ignore first (header) and last line (checkSum).
  for I := 1 to (sl.Count - 2) do
  begin
    id := DTData.tblDTEntrant.RecordCount + 1;
    DTData.tblDTEntrant.Append;
    ExtractLane(sl[I],ADTFileType, lane);
    ExtractTimeKeepers(sl[I], ADTFileType, TimeKeepers);
    {
    if EnabledSplits then
      ExtractSplits(sl[I], Splits);
    }
    // primary key
    DTData.tblDTEntrant.fieldbyName('EntrantID').AsInteger := id;
    // master.detail.
    DTData.tblDTEntrant.fieldbyName('HeatID').AsInteger := DTHeatID;
    // SYNC with SwimClubMeet - INDV or TEAM lane
    DTData.tblDTEntrant.fieldbyName('Lane').AsInteger := lane;
    // Should read 'Lane: #Lane#'
    s := 'Lane: ' + IntToStr(lane);
    DTData.tblDTEntrant.fieldbyName('Caption').AsString := s;
    // Auto-Calc best racetime.
    DTData.tblDTEntrant.fieldbyName('AutoTime').AsBoolean := true;
    // Swimmers calculated racetime.
    DTData.tblDTEntrant.fieldbyName('CalcTime').Clear;
    // graphic used in column[1] - for noodle drawing...
    DTData.tblDTEntrant.fieldbyName('imgPatch').AsInteger := 0;

    for j := 0 to High(TimeKeepers) do
    begin
      // Generate field names
      TimeFieldName := Format('Time%d', [j + 1]);
      TimeModeFieldName := Format('Time%d', [j + 1]) + 'Mode';
      TimeModeFieldName := Format('Time%d', [j + 1]) + 'Err';
      // Set race-time and use flag based on TimeKeepers value
      if TimeKeepers[j] > 0 then
      begin
        DTData.tblDTEntrant.FieldByName(TimeFieldName).AsDateTime := TDateTime(TimeKeepers[j]);
        DTData.tblDTEntrant.FieldByName(TimeModeFieldName).AsInteger := Ord(tmAutoEnabled);
        DTData.tblDTEntrant.FieldByName(TimeModeFieldNameErr).Clear;
      end
      else
      begin
        DTData.tblDTEntrant.FieldByName(TimeFieldName).Clear;
        DTData.tblDTEntrant.FieldByName(TimeModeFieldName).AsInteger := Ord(tmAutoDisabled);
        DTData.tblDTEntrant.FieldByName(TimeModeFieldNameErr).AsInteger := Ord(tmeEmpty);
      end;
    end;

    {TODO -oBSA -cGeneral : Calculate deviation for each timekeeper?}
    DTData.tblDTEntrant.fieldbyName('Deviation1').Clear;
    DTData.tblDTEntrant.fieldbyName('Deviation2').Clear;
    DTData.tblDTEntrant.fieldbyName('Deviation3').Clear;


    // Split Times
    ExtractSplits(sl[i], ADTFileType, Splits);
    for j := 0 to High(Splits) do
    begin
      // Generate field names
      SplitFieldName := Format('Split%d', [j + 1]);
      if Splits[j] > 0 then
        DTData.tblDTEntrant.fieldbyName(SplitFieldName).AsDateTime := TDateTime(Splits[j])
       else
        DTData.tblDTEntrant.FieldByName(SplitFieldName).Clear;
    end;

    DTData.tblDTEntrant.Post;

  end;

end;

procedure TdtUtils.ProcessEvent(AFileName: TFileName; SessionID: integer;
  ADTFileType: dtFileType);
var
  sl: TStringList;
  SessionNum, EventNum, HeatNum, i, id, fnEventNum: integer;
  GenderStr, checkSum, filestr, fnRoundStr: string;
  Found: boolean;
begin
  id := 0;
  // NOTE: Assumption - FileExists!
  // DEFAULT Precedence dtPrecHeader
  fileStr := ExtractFileName(AFileName);
  fnEventNum := GetFileNameEventNum(fileStr, ADTFileType);
  if (FPrecedence = dtPrecFileName) then
    i := fnEventNum
  else
    i := ExtractEventNum(AFileName, ADTFileType);

  Found := DTData.LocateEventNum(i);
  if Found then
    id := DTData.tblDTEvent.FieldByName('EventID').AsInteger
  else
  begin
    sl := TStringList.Create();
    sl.LoadFromFile(AFileName);
    if not sl.IsEmpty then
    begin
      // calculate the IDENTIFIER.
      id := DTData.tblDTEvent.RecordCount + 1;
      // first line represents SessionNum, EventNum, HeatNum, gender (A,B,X)
      // delimeter is ';'
      ExtractHeader(sl[0], ADTFileType, SessionNum, EventNum, HeatNum,
        GenderStr);
      // checksum is the last line
      ExtractFooter(sl[sl.Count - 1], ADTFileType, checkSum);
      // NEW RECORD.
      DTData.tblDTEvent.Append;
      // Primary Key.
      DTData.tblDTEvent.fieldbyName('EventID').AsInteger := id;
      // master - detail. Also Index Field.
      DTData.tblDTEvent.fieldbyName('SessionID').AsInteger := SessionID;
      // Derived from SplitString Field[1]
      // SYNC with SCM dbo.qryEvent.EventNum.
      // Does EventNum = fnEventNum?
      DTData.tblDTEvent.fieldbyName('EventNum').AsInteger := EventNum;
      // the heat number as shown in the DT filename.
      DTData.tblDTEvent.fieldbyName('fnEventNum').AsInteger := fnEventNum;
      // Event Number ....
      // Add round info?
      DTData.tblDTEvent.fieldbyName('Caption').AsString := 'Event: ' +
      IntToStr(EventNum);
      // DO4 A=boys, B=girls, X=any.
      DTData.tblDTEvent.fieldbyName('GenderStr').AsString := GenderStr;
      // ROUND is at event level..
      fnRoundStr := GetFileNameRoundStr(fileStr, ADTFileType);
      // Round – “A” for all, “P” for prelim or “F” for final
      // derived from FileName
      fnRoundStr := Copy(fnRoundStr, 1, 1);
      DTData.tblDTEvent.fieldbyName('fnRoundStr').AsString := fnRoundStr;
      // POST
      DTData.tblDTEvent.Post;
    end;
    sl.free;
  end;
  // LANES + TIMEKEEPERS 1-3 + SPLITS (upto 10).
  ProcessHeat(AFileName, id, ADTFileType);
end;

procedure TdtUtils.ProcessHeat(AFileName: TFileName; EventID: integer; ADTFileType: dtFileType);
var
  SessionID, EventNum, HeatNum, id: integer;
  Gender, checksum, HashStr: string;
  sl: TStringList;
begin
  // read header and lane information (Racetimes x3).
  sl := TStringList.Create();
  sl.LoadFromFile(AFileName);
  if not sl.IsEmpty then
  begin
    // first line represents SessionNum, EventNum, HeatNum, gender (A,B,X)
    // delimeter is ';'
    ExtractHeader(sl[0], ADTFileType, SessionID, EventNum, HeatNum, Gender);
    // checksum is the last line
    checksum := sl[sl.Count - 1];
    // calculate the IDENTIFIER.
    id := DTData.tblDTHeat.RecordCount + 1;
    // NEW RECORD.
    DTData.tblDTHeat.Append;
    // PK
    DTData.tblDTHeat.fieldbyName('HeatID').AsInteger := id;
    // master - detail.
    DTData.tblDTHeat.fieldbyName('EventID').AsInteger := EventID;
    // TIME STAMP
    DTData.tblDTEvent.fieldbyName('TimeStampDT').AsDateTime := Now;
    // HEADER - first line of text - common
    DTData.tblDTHeat.fieldbyName('HeatNum').AsInteger := HeatNum;
    // the heat number as shown in the DT filename.

    DTData.tblDTHeat.fieldbyName('fnHeatNum').AsInteger := HeatNum;
    DTData.tblDTHeat.fieldbyName('Caption').AsString := 'Heat Number: ' + IntToStr(HeatNum);
    // Time stamp of file - created by Dolphin Timing system on write of file.
    DTData.tblDTEvent.fieldbyName('CreatedDT').AsDateTime :=TFile.GetCreationTime(AFileName);
    // Path only - may be redundant?
    // The system preferences stores the path direction to the DT Meet Bin.
    DTData.tblDTHeat.fieldbyName('Path').AsString := ExtractFilePath(AFileName);
    // FileName includes file extension.    (.DO3, .DO4)
    // determines dtFileType dtDO3, dtDO4.
    DTData.tblDTHeat.fieldbyName('FileName').AsString := ExtractFileName(AFileName);
    // CHECKSUM - last line of text - common
    // Max of 16 characters
    checksum := Copy(checksum, 1, 16);
    DTData.tblDTHeat.fieldbyName('CheckSum').AsString := checksum;
    // this param's value will be resolved later ...
    DTData.tblDTHeat.fieldbyName('dtBadFN').AsBoolean := false;
    // DO3 - SplitString Field[2] hash number (alpha-numerical).
    // DO4 - SplitString Field[3] hash number (numerical - sequence).
    HashStr := ExtractHashStr(AFileName, ADTFileType);
    // MAX of 8 characters
    HashStr := Copy(HashStr, 1, 8);
    DTData.tblDTSession.fieldbyName('HashStr').AsString := HashStr;
    // CONVERT DO4 - SplitString Field[3]
    // A sequential number for each file (within the DT Session)
    // - produced by the Dolphin Timing session.
    if ADTFileType = dtDO4 then
      DTData.tblDTSession.fieldbyName('fnRaceID').AsInteger:= StrToIntDef(HashStr, 0);

    DTData.tblDTHeat.Post;
    // LANES + TIMEKEEPERS 1-3 + SPLITS (upto 10).
    {TODO -oBSA -cGeneral : Heat can be TEAM or INDV event... }
    // if scmEventType = etINDV
    ProcessEntrant(sl, id, ADTFileType);
    // else
    // GetDTTEAM(sl, id);
  end;
  sl.free;
end;

procedure TdtUtils.ProcessSession(AFileName: TFileName; ADTFileType: dtFileType);
var
  i, id, fnSessionNum, fnEventNum, fnHeatNum, ASessionNum: integer;
  HashStr, fnRoundStr, fileStr: string;
  s: string;
  fCreationDT: TDateTime;
  fs: TFormatSettings;
  Found: boolean;
begin
  // NOTE: Assumption - FileExists!
  // DEFAULT Precedence dtPrecHeader
  fileStr := ExtractFileName(AFileName);
  if (FPrecedence = dtPrecFileName) then
    // Use the SessionNumber found in FileName
    i := GetFileNameSessionNum(fileStr, ADTFileType)
  else
    // Use the SessionNumber found in line one ('Header')
    i := ExtractSessionNum(AFileName, ADTFileType);

  Found := DTData.LocateSessionNum(i);
  if Found then
  begin
    id := DTData.tblDTSession.FieldByName('SessionID').AsInteger;
  end
  else
  begin
    id := DTData.tblDTSession.RecordCount + 1;
    // Get the creation time of the specified file
    fCreationDT := TFile.GetCreationTime(AFileName);
    // Extract data fields from the Dolphin Timing filename.
    ExtractDTFile(AFileName, ADTFileType, fnSessionNum, fnEventNum, fnHeatNum, fnRoundStr, Hashstr);
    DTData.tblDTSession.Append;
    // Primary Key
    DTData.tblDTSession.FieldByName('SessionID').AsInteger := id;
    // Derived from line one ('Header') within the DT file.
    // They should match!
    ASessionNum := ExtractSessionNum(AFileName, ADTFileType);
    DTData.tblDTSession.fieldbyName('SessionNum').AsInteger := ASessionNum;
    // Derived from filename : Last three digits of SCM qrySession.SessionID.
    DTData.tblDTSession.fieldbyName('fnSessionNum').AsInteger := fnSessionNum;
    // Derived from filename : matches SCM qryEvent.EventNum.
    DTData.tblDTSession.fieldbyName('fnEventNum').AsInteger := fnEventNum;
    // Derived from filename : matches SCM qryHeat.HeatNum.
    DTData.tblDTSession.fieldbyName('fnHeatNum').AsInteger := fnHeatNum;
    // Creation date of file - by Dolphin Timing system.
    DTData.tblDTSession.fieldbyName('SessionStart').AsDateTime := fCreationDT;
    // TimeStamp
    DTData.tblDTSession.fieldbyName('CreatedOn').AsDateTime := Now;
    // Create a session caption.
    fs := TFormatSettings.Create;
    fs.DateSeparator := '_';
    s := 'Session: ' + IntToStr(fnSessionNum) + ' Date: ' + DatetoStr(fCreationDT, fs);
    DTData.tblDTSession.fieldbyName('Caption').AsString := s;
    // FINALIZE - POST NEW RECORD.
    DTData.tblDTSession.Post;
  end;
  // process event >> heat >> entrant.
  ProcessEvent(AFileName, id, ADTFileType);
end;

function TdtUtils.ExtractHashStr(const AFileName: TFileName;
  ADTFileType: dtFileType): string;
var
  sl: TStringList;
  Fields: TArray<string>;
begin
  result := '';
  if FileExists(AFileName) then
  begin
    sl := TStringList.Create();
    sl.LoadFromFile(AFileName);
    if not sl.IsEmpty then
    begin
      Fields := SplitString(sl[0], ';');
      if (ADTFileType = dtDO3) then
      begin
      if Length(Fields) = 3  then
        result := Fields[2];
      end;
      if (ADTFileType = dtDO4) then
      begin
      if Length(Fields) = 4  then
        result := Fields[3];
      end;
    end;
    sl.Free;
  end;
end;

{
function TdtUtils.GetFileCreationTime(const FileName: TFileName): TDateTime;
var
  Handle: THandle;
  FindData: TWin32FindData;
  SystemTime: TSystemTime;
  LocalFileTime: TFileTime;
begin
  Handle := FindFirstFile(PChar(FileName), FindData);
  if Handle <> INVALID_HANDLE_VALUE then
  begin
    Windows.FindClose(Handle);
    // Convert file time to local file time
    if FileTimeToLocalFileTime(FindData.ftCreationTime, LocalFileTime) then
    begin
      // Convert file time to system time
      if FileTimeToSystemTime(LocalFileTime, SystemTime) then
      begin
        // Convert system time to TDateTime
        Result := SystemTimeToDateTime(SystemTime);
        Exit;
      end;
    end;
  end;
  // Return 0 if there is an error
  Result := 0;
end;
}

procedure TdtUtils.ExtractHeader(const InputStr: string;
  ADTFileType: dtFileType;
  var Session: integer;
  var Event: integer;
  var Heat: integer;
  var Gender: string);
var
  Fields: TArray<string>;
begin
  // Split string by the ';' character
  // example 0;0;1;A  (DO3)
  // example 1;1;1;A (DO4)
  Session := 0;
  Event := 0;
  Heat := 0;
  // Gender string A-boys B-girls X-all
  // Round – “A” for all, “P” for prelim or “F” for final
  Gender := 'X';

  Fields := SplitString(InputStr, ';');
  if Length(Fields) <> 4 then exit;   // return default assignment.
  Session := StrToIntDef(Fields[0], 0);
  Event := StrToIntDef(Fields[1], 0);
  Heat := StrToIntDef(Fields[2], 0);
  Gender := Copy(Fields[3], 1, 1);
end;

{
function TdtUtils.ExtractHeaderEventNum(sl: TStringList): integer;
var
  Fields: TArray<string>;
begin
  result := 0;
  if not sl.IsEmpty then
  begin
    Fields := SplitString(sl[0], ';');
    if Length(Fields) > 1 then
      result := StrToIntDef(Fields[1], 0);
  end;
end;

function TdtUtils.ExtractHeaderGenderChar(sl: TStringList): char;
var
  Fields: TArray<string>;
begin
  result := #0;
  if not sl.IsEmpty then
  begin
    Fields := SplitString(sl[0], ';');
    if Length(Fields) > 3 then
    begin
      result := Fields[3].Chars[0];
    end;
  end;
end;

function TdtUtils.ExtractHeaderHeatNum(sl: TStringList): integer;
var
  Fields: TArray<string>;
begin
  result := 0;
  if not sl.IsEmpty then
  begin
    Fields := SplitString(sl[0], ';');
    if Length(Fields) > 2 then
      result := StrToIntDef(Fields[2], 0);
  end;
end;

function TdtUtils.ExtractHeaderSessionNum(sl: TStringList): integer;
var
  Fields: TArray<string>;
begin
  result := 0;
  if not sl.IsEmpty then
  begin
    Fields := SplitString(sl[0], ';');
    if Length(Fields) > 0 then
      result := StrToIntDef(Fields[0], 0);
  end;
end;
}

function TdtUtils.ExtractSessionNum(const AFileName: TFileName;
  ADTFileType: dtFileType): integer;
var
  sl: TStringList;
  Fields: TArray<string>;
begin
  result := 0;
  if FileExists(AFileName) then
  begin
    sl := TStringList.Create();
    sl.LoadFromFile(AFileName);
    if not sl.IsEmpty then
    begin
      Fields := SplitString(sl[0], ';');
      if Length(Fields) > 0 then
        result := StrToIntDef(Fields[0], 0);
    end;
    sl.Free;
  end;
end;

procedure TdtUtils.ExtractSplits(const InputStr: string;
  ADTFileType: dtFileType;
  ASplits: array of TTime);
var
  Fields: TArray<string>;
  i: Integer;
begin

{
Number of Splits – (1-10) Enter 1 to use the first time as the final time. A single length
race would have only one split (i.e. the final time), and multi length races would have
one split for every lap.
o Example 1: A 25 yard race in a 25 yard pool would have a split count of 1
meaning only on one time is collected (i.e. the final time)
o Example 2: A 100 meter race in a 50 meter pool would also have a split count
of 1 (i.e: the final time of the single lap.)
o Example 3: A 200 yard race in a 25 yard pool would have a split count of 4.
}

  // Initialize timekeepers
  for i := Low(ASplits) to High(ASplits) do ASplits[i] := 0;

  // Only DO4 captures split data?
  if not (ADTFileType = dtDO4) then exit;

  // Split string by the ';' character
  Fields := InputStr.Split([';']);

  // Field[0] - lane number
  // Field[1] ... [3] - timekeepers data.
  // Fiels[4] - split data index
  // Extract split data.
  if Length(Fields) > 4 then
  begin
    for i := 4 to Length(Fields) - 1 do  // ignore Fields[0] = lane number.
    begin
      if Length(Fields[i]) > 0 then
      begin
        if i <= High(ASplits) then // trap array index overrun
          ASplits[i] := ConvertDTTimeToTime(Fields[i])
      end;
    end;
  end;

end;

procedure TdtUtils.ExtractLane(const InputStr: string;
  ADTFileType: dtFileType;
  var lane: integer);
var
  Fields: TArray<string>;
  s: string;
begin
  lane := 0;
  // Split string by the ';' character
  Fields := SplitString(InputStr, ';');
  if Length(Fields) = 0 then exit;   // Input string is empty - err.
  // examples.
  // DO4 - 'Lane1;55.98;;'
  // DO3 - '1;95.25;;'
  s := StripAlphaChars(Fields[0]);
  if Length(s) > 0 then
    lane := StrToIntDef(s, 0); // Extract the lane as an integer
end;

procedure TdtUtils.ExtractTimeKeepers(const InputStr: string;
  ADTFileType: dtFileType;
  ATimeKeepers: array of TTime);
var
  Fields: TArray<string>;
  i: integer;
begin
  // Split string by the ';' character
  Fields := SplitString(InputStr, ';');

  // Note: Dolphin Timing allows for three timekeepers.
  // Fields[0] = lane number.
  // Fields[1], Fields[2], Fields[3] - TimeKeepers data in DTTime format.
  // examples.
  // DO4 - 'Lane1;55.98;;'
  // DO3 - '1;95.25;;'

  // Initialize timekeepers
  for i := Low(ATimeKeepers) to High(ATimeKeepers) do ATimeKeepers[i] := 0;

  // Extract timekeepers data.
  if Length(Fields) > 1 then
  begin
    for i := 1 to Length(Fields) - 1 do  // ignore Fields[0] = lane number.
    begin
      if Length(Fields[i]) > 0 then
      begin
        if i <= High(ATimeKeepers) then // trap array index overrun
          ATimeKeepers[i] := ConvertDTTimeToTime(Fields[i])
      end;
    end;
  end;
end;

class operator TdtUtils.Finalize(var Dest: TdtUtils);
begin
  Dest.fStrList.Free;
end;

procedure TdtUtils.ExtractDTFile(const AFileName: TFileName;
  ADTFileType: dtFileType; var SessionID, EventID, HeatID: integer; var RoundStr,
  HashStr: string);
var
  AFileStr: string;
begin
  AFileStr := ExtractFileName(AFileName);
  SessionID := GetFileNameSessionNum(AFileStr, ADTFileType);
  EventID := GetFileNameEventNum(AFileStr, ADTFileType);
  HeatID := GetFileNameHeatNum(AFileStr, ADTFileType);
  RoundStr := GetFileNameRoundStr(AFileStr, ADTFileType);
  HashStr := GetFileNameHashStr(AFileStr, ADTFileType);

end;

function TdtUtils.ExtractEventNum(const AFileName: TFileName;
  ADTFileType: dtFileType): integer;
var
  sl: TStringList;
  Fields: TArray<string>;
begin
  result := 0;
  if FileExists(AFileName) then
  begin
    sl := TStringList.Create();
    sl.LoadFromFile(AFileName);
    if not sl.IsEmpty then
    begin
      Fields := SplitString(sl[0], ';');
      if Length(Fields) > 1 then
        result := StrToIntDef(Fields[1], 0);
    end;
    sl.Free;
  end;
end;

procedure TdtUtils.ExtractFooter(const InputStr: string;
  ADTFileType: dtFileType; var ACheckSum: string);
begin
  case ADTFileType of
    dtDO4, dtDO3:
    begin
      // checksum is the last line
      // 16 characters
      if Length(InputStr) = 16 then
        ACheckSum := InputStr
      else
        ACheckSum := '';
    end;
    dtUnknown, dtALL: ACheckSum := '';
  end;
end;


{
function TdtUtils.ExtractFooterHashStr(sl: TStringList): string;
begin

end;
}

function TdtUtils.GetFileNameEventNum(const AFileStr: string;
        ADTFileType: dtFileType): integer;
var
  Fields: TArray<string>;
begin
  result := 0;
  // Split string by the '-' character
  Fields := SplitString(AFileStr, '-');
  if Length(Fields) > 2 then
    // Extract the first field - SessionID
    result := StrToIntDef(Fields[1], 0);
end;


{
function TdtUtils.GetFileNameGenderStr(const AFileStr: string;
  ADTFileType: dtFileType): string;
var
  GenderStr: string;
  Fields: TArray<string>;
begin
  result := '';
  GenderStr := '';
    // Split string by the '-' character
    Fields := SplitString(AFileStr, '-');
  // The third field has A or B or X appended at end of string.
  // Copy uses one-based array indexing.
  // A = boys, B = girls, X = mixed gender...
  if (ADTFileType = dtDO4) then
  begin
    if Length(Fields) > 3 then
    begin
      GenderStr := RightStr(Fields[2], 1);
      if (GenderStr <> 'A') and (GenderStr <> 'B') then GenderStr := 'X';
    end;
  end;
  if Length(GenderStr)>0 then
    result := GenderStr;
end;
}

function TdtUtils.GetFileNameHashStr(const AFileStr: string;
  ADTFileType: dtFileType): string;
var
  HashStr: string;
  Fields: TArray<string>;
begin
  result := '';
  HashStr := '';
  // Split string by the '-' character
  Fields := SplitString(AFileStr, '-');
  case ADTFileType of
    dtUnknown: ;
    dtDO4:
      begin
        if Length(Fields) > 4 then
        begin
          // The fourthfield has a '.' delimiter for the string and the '.do4' part
          HashStr := Copy(Fields[3], 1, Pos('.', Fields[3]) - 1);
        end;
      end;
    dtDO3:
      begin
        if Length(Fields) > 3 then
        begin
          // The third field has a '.' delimiter for the string and the '.do3' part
          HashStr := Copy(Fields[2], 1, Pos('.', Fields[2]) - 1);
        end;
      end;
    dtALL: ;
  end;
  if Length(HashStr) > 0 then
    result := HashStr;
end;

function TdtUtils.GetFileNameHeatNum(const AFileStr: string;
        ADTFileType: dtFileType): integer;
var
  Fields: TArray<string>;
  s: string;
begin
  result := 0;
  if (ADTFileType = dtDO4) then
  begin
    // Split string by the '-' character
    Fields := SplitString(AFileStr, '-');
    if Length(Fields) > 3 then
    begin
      s := StripAlphaChars(Fields[2]);
      // Extract the first field - SessionID
      result := StrToIntDef(Fields[2], 0);
    end;
  end;
end;


function TdtUtils.GetFileNameRoundStr(const AFileStr: string;
  ADTFileType: dtFileType): string;
var
  RoundStr: string;
  Fields: TArray<string>;
begin
  result := '';
  RoundStr := '';
    // Split string by the '-' character
    Fields := SplitString(AFileStr, '-');
  // Round – “A” for all, “P” for prelim or “F” for final.
  // Copy uses one-based array indexing.
  if (ADTFileType = dtDO4) then
  begin
    if Length(Fields) > 3 then
    begin
      RoundStr := RightStr(Fields[2], 1);
    end;
  end;
  if (Length(RoundStr) > 0) then
  begin
    // Round – “A” for all, “P” for prelim or “F” for final.
    if ContainsText('APF', RoundStr) then
    // or use: if Contains(RoundStr, TArray<string>.Create('A', 'P', 'F')) then
      result := RoundStr;
  end;
end;


function TdtUtils.GetFileNameSessionNum(const AFileStr: string;
        ADTFileType: dtFileType): integer;
var
  Fields: TArray<string>;
begin
  result := 0;
  // Split string by the '-' character
  Fields := SplitString(AFileStr, '-');
  if Length(Fields) > 1 then
    // Extract the first field - SessionID
    result := StrToIntDef(Fields[0], 0);
end;

class operator TdtUtils.Initialize(out Dest: TdtUtils);
begin
  Dest.fStrList := TStringList.Create;
end;

procedure TdtUtils.ProcessDirectory(const ADirectory: string; pBar: TProgressBar);
var
  LList, LListDO3, LListDO4: TStringDynArray;
  LSearchOption: TSearchOption;
  I: integer;
  ft: dtFileType;
begin
{
NOTE: The pattern '*.DO?' will match any file with a .DO extension followed
by any single character. This means it will match *.DO3, *.DO4, *.DO5, etc.
.. but to future proof the following method was chosen.
}
  if Assigned(pBar) then pBar.Position := 0;
  { Select the search option }
  // do not do recursive extract into subfolders
  LSearchOption := TSearchOption.soTopDirectoryOnly;
  try
    { For files use GetFiles method }
    LListDO3 := TDirectory.GetFiles(ADirectory, '*.DO3', LSearchOption);
    LListDO4 := TDirectory.GetFiles(ADirectory, '*.DO4', LSearchOption);

    { Combine the lists }
    SetLength(LList, Length(LListDO3) + Length(LListDO4));
    if Length(LListDO3) > 0 then
      Move(LListDO3[0], LList[0], Length(LListDO3) * SizeOf(string));
    if Length(LListDO4) > 0 then
      Move(LListDO4[0], LList[Length(LListDO3)], Length(LListDO4) * SizeOf(string));

    { Extract DATA and Populate the memory table. }
    for I := 0 to Length(LList) - 1 do
    begin
      ft := GetDTFileTypeOfFile(LList[I]);
      ProcessSession(LList[I], ft);
      // update progress bar.
      if Assigned(pBar) then
      begin
        pBar.Position := Trunc(Ceil((I + 1) / Length(LList) * 100));
        pBar.RePaint;
      end;
    end;
  except
    { Catch the possible exceptions }
    MessageBox(0, PChar('Incorrect path or search mask'),
      PChar('Extract Dolphin .DO3 and .DO4 Files'), MB_ICONERROR or MB_OK);
  end;
end;

procedure TdtUtils.PrepareDTData();
begin
  fPrecedence := dtPrecHeader;

  // clear all data records ....
  DTData.tblDTSession.EmptyDataSet;
  DTData.tblDTHeat.EmptyDataSet;
  DTData.tblDTEntrant.EmptyDataSet;
  DTData.tblDTNoodle.EmptyDataSet;

  // re-establish Master Detail ...
  DTData.tblDTEvent.MasterSource := DTData.dsDTSession;
  DTData.tblDTEvent.MasterFields := 'SessionID';
  DTData.tblDTEvent.DetailFields := 'SessionID';
  DTData.tblDTEvent.IndexFieldNames := 'SessionID';

  DTData.tblDTHeat.MasterSource := DTData.dsDTEvent;
  DTData.tblDTHeat.MasterFields := 'EventID';
  DTData.tblDTHeat.DetailFields := 'EventID';
  DTData.tblDTHeat.IndexFieldNames := 'EventID';

  DTData.tblDTEntrant.MasterSource := DTData.dsHeat;
  DTData.tblDTEntrant.MasterFields := 'HeatID';
  DTData.tblDTEntrant.DetailFields := 'HeatID';
  DTData.tblDTEntrant.IndexFieldNames := 'HeatID';

  DTData.tblDTNoodle.MasterSource := DTData.dsDTHeat;
  DTData.tblDTNoodle.MasterFields := 'HeatID';
  DTData.tblDTNoodle.DetailFields := 'HeatID';
  DTData.tblDTNoodle.IndexFieldNames := 'HeatID';

end;

Procedure TdtUtils.PopulateDTData(const ADirectory: string; pBar: TProgressBar);
begin
  DTData.tblDTSession.DisableControls;
  DTData.tblDTEvent.DisableControls;
  DTData.tblDTHeat.DisableControls;
  DTData.tblDTEntrant.DisableControls;
  DTData.tblDTNoodle.DisableControls;

  if Assigned(pBar) then pBar.Position := 0;

  ProcessDirectory(ADirectory, pBar);

  DTData.tblDTSession.First;
  dtData.tblDTEvent.First;
  dtData.tblDTHeat.First;

  DTData.tblDTSession.EnableControls;
  DTData.tblDTEvent.EnableControls;
  DTData.tblDTHeat.EnableControls;
  DTData.tblDTEntrant.EnableControls;
  DTData.tblDTNoodle.EnableControls;

  end;

function TdtUtils.GetDTFileTypeOfDirectory(const ADirectory: string): dtFileType;
var
  LList: TStringDynArray;
  LSearchOption: TSearchOption;
  fileMask, fn: string;
  I, countDO3, countDO4: integer;
  ft: dtFileType;
begin
  fileMask := '*.DO?';
  countDO3 := 0;
  countDO4 := 0;
  result := dtUnknown;
  // do not do recursive extract into subfolders
  LSearchOption := TSearchOption.soTopDirectoryOnly;
  try
    { For files use GetFiles method }
    LList := TDirectory.GetFiles(ADirectory, fileMask, LSearchOption);
    for I := 0 to Length(LList) - 1 do
    begin
      fn := ExtractFileName(LList[I]); // avoid mask match in directory part.
      ft := GetDTFileTypeOfFile(fn);
      if ft = dtFileType.dtDO3 then Inc(countDO3);
      if ft = dtFileType.dtDO4 then Inc(countDO4);
    end;
  except
    { Catch the possible exceptions }
    MessageBox(0, PChar('Incorrect path or search mask'),
      PChar('Get file type of directory...'), MB_ICONERROR or MB_OK);
    exit;
  end;
  if (countDO3 > 0) and (countDO4 = 0) then
    result := dtDO3
  else if (countDO3 = 0) and (countDO4 > 0) then
    result := dtDO4
  else
    result := dtALL;
  end;

function TdtUtils.GetDTFileTypeOfFile(const AFileName: string): dtFileType;
begin
  result := dtUnknown;
  if AfileName.Contains('.DO3') then
    result := dtDO3
  else if AfileName.Contains('.DO4') then
    result := dtDO4;
end;



{ TdtLane }

function TdtLane.ExtractLane(sl: TStringList; LaneNum: integer): boolean;
var
  i, ALaneNum: integer;
  s: string;
  Fields: TArray<string>;
begin
  result := false;
  // iterate though string list -
  if sl.IsEmpty then exit;
  // base zero, ignore header and footer lines...
  if (sl.Count > 1) then
  begin
    for I := 1 to (sl.Count - 2) do
    begin
      Fields := SplitString(sl[i], ';');
      s := StripAlphaChars(Fields[0]);
      ALaneNum := StrToIntDef(s, 0);
      if ALaneNum = LaneNum then
      begin
        ExtractLane(sl[i]);
        result := true;
        break;
      end;
    end;
  end;
end;

function TdtLane.ExtractLane(InputStr: string): boolean;
var
  Fields: TArray<string>;
  s: string;
  i: integer;
begin
  lane := 0;
  result := false;
  // Split string by the ';' character
  Fields := SplitString(InputStr, ';');
  if Length(Fields) = 0 then exit;   // Input string is empty - err.
  // examples.
  // DO4 - 'Lane1;55.98;;'
  // DO3 - '1;95.25;;'
  s := StripAlphaChars(Fields[0]);
  if Length(s) > 0 then
    lane := StrToIntDef(s, 0); // Extract the lane as an integer

  // Initialize timekeepers
  for i := Low(TimeKeepers) to High(TimeKeepers) do TimeKeepers[i] := 0;

  // Extract timekeepers data.
  if Length(Fields) > 1 then
  begin
    for i := 1 to Length(Fields) - 1 do  // ignore Fields[0] = lane number.
    begin
      if Length(Fields[i]) > 0 then
      begin
        if i <= High(TimeKeepers) then // trap array index overrun
          TimeKeepers[i] := ConvertDTTimeToTime(Fields[i])
      end;
    end;
  end;
end;

end.

