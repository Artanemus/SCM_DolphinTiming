unit dtUtils;

interface

uses dmDTData, vcl.ComCtrls, Math, System.Types, System.IOUtils,
  SysUtils, Windows, StrUtils, System.Classes;

type
  PTime = ^TTime;

var
  Splits: array[0..9] of TTime;
  TimeKeepers: array[0..2] of TTime;

function GetFileCreationTime(const FileName: string): TDateTime;

// GENERIC ...
procedure ExtractHeader(const InputStr:
  string; var Session: integer;
  var Event: integer;
  var Heat: integer;
  var Gender: string);

procedure ExtractLane(const InputStr: string;  var lane: integer);

procedure ExtractTimeKeepers(const InputStr: string;
  ATimeKeepers: array of TTime; StartIndex: Integer);

procedure ExtractSplits(const InputStr: string;
  ASplits: array of TTime; StartIndex: Integer);

procedure ExtractFileNameFieldsDO3(const InputStr: string;
  var Session: integer;
  var Event: integer;
  var GUID: string);

procedure ExtractFileNameFieldsDO4(const InputStr: string;
  var Session: integer;
  var Event: integer;
  var Heat: integer;
  var Gender:
  string; var
  RaceID: string);

procedure PrepareDTData();
procedure PopulateDTData(const ADirectory: string; pBar: TProgressBar);
procedure AppendDTData(const AFileName:string);

// function HasSession(aSessionID: integer);
function GetDTFileType(const ADirectory: string): integer;

// ---------------------------------------------------

{
This is a CSV file and can be hand typed or generated by meet management software.
Each line of this file should be formatted as follows:
Event Number,EventName,Number of Heats,Number of Splits,Round.
Example:
  1A,Boys 50 M Free,4,1,P
  1B,Girls 50 M Free,5,1,P
  2A,Boys 100 M Breaststroke,2,2,P
  2B,Girls 100 M Breaststroke,2,2,P
...
}

implementation

var
  DolphinTimingFileType: integer;


procedure AppendDTData(const AFileName:string);
Begin
  // todo
End;

procedure GetDTLane(sl: TStringList; DTHeatID: integer);
var
  id, I, j, lane: integer;
  TimeFieldName, UseFieldName, SplitFieldName: string;
begin
  // A record for each lane.
  // Ignore first (header) and last line (checkSum).
  for I := 1 to (sl.Count - 2) do
  begin
    id := DTData.tblDTLane.RecordCount + 1;
    DTData.tblDTLane.Append;

    ExtractLane(sl[I], lane);
    ExtractTimeKeepers(sl[I], TimeKeepers, 1);
    ExtractSplits(sl[I], Splits, 4);

    DTData.tblDTLane.fieldbyName('DTLaneID').AsInteger := id; // master - detail.
    DTData.tblDTLane.fieldbyName('DTHeatID').AsInteger := DTHeatID;
      // master - detail.
    DTData.tblDTLane.fieldbyName('Lane').AsInteger := lane;

    for j := 0 to High(TimeKeepers) do
    begin
      // Generate field names
      TimeFieldName := Format('Time%d', [j + 1]);
      UseFieldName := Format('UseTime%d', [j + 1]);
      // Set race-time and use flag based on TimeKeepers value
      if TimeKeepers[j] > 0 then
      begin
        DTData.tblDTLane.FieldByName(TimeFieldName).AsDateTime := TDateTime(TimeKeepers[j]);
        DTData.tblDTLane.FieldByName(UseFieldName).AsBoolean := True;
      end
      else
      begin
        DTData.tblDTLane.FieldByName(TimeFieldName).Clear;
        DTData.tblDTLane.FieldByName(UseFieldName).AsBoolean := False;
      end;
    end;

    DTData.tblDTLane.fieldbyName('imgPatch').AsInteger := 0;
    DTData.tblDTLane.fieldbyName('AutoTime').AsBoolean := true;

    for j := 0 to High(Splits) do
    begin
      // Generate field names
      SplitFieldName := Format('Split%d', [j + 1]);
      if Splits[j] > 0 then
        DTData.tblDTLane.fieldbyName(SplitFieldName).AsDateTime := TDateTime(Splits[j])
       else
        DTData.tblDTLane.FieldByName(SplitFieldName).Clear;
    end;

    DTData.tblDTLane.Post;
  end;

end;

procedure GetDTHeat(fn: string; DTID: integer);
var
  sl: TStringList;
  Session, Event, Heat, id: integer;
  Gender, checksum: string;
begin
  // read header and lane information (Racetimes x3).
  sl := TStringList.Create();
  sl.LoadFromFile(fn);
  if not sl.IsEmpty then
  begin
    // first line represents session, event, heat, gender (A,B,X)
    // delimeter is ';'
    ExtractHeader(sl[0], Session, Event, Heat, Gender);
    // checksum is the last line
    checksum := sl[sl.Count - 1];
    // calculate the IDENTIFIER.
    id := DTData.tblDTHeat.RecordCount + 1;
    // NEW RECORD.
    DTData.tblDTHeat.Append;
    DTData.tblDTHeat.fieldbyName('DTHeatID').AsInteger := id; // master - detail.
    DTData.tblDTHeat.fieldbyName('DTID').AsInteger := DTID; // master - detail.
    // HEADER - first line of text - common
    DTData.tblDTHeat.fieldbyName('Session').AsInteger := Session;
    DTData.tblDTHeat.fieldbyName('Event').AsInteger := Event;
    DTData.tblDTHeat.fieldbyName('Heat').AsInteger := Heat;
    DTData.tblDTHeat.fieldbyName('Gender').AsString := Gender;
    // CHECKSUM - last line of text - common
    DTData.tblDTHeat.fieldbyName('CheckSum').AsString := checksum;
    DTData.tblDTHeat.Post;
    // LANES + TIMEKEEPERS 1-3 + SPLITS (upto 10).
    GetDTLane(sl, id);
  end;
  sl.free;
end;

procedure GetDT(fn: string);
var
  id, fSessionNum, FEventNum, FHeatNum: integer;
  fGUID, FGender: string;
  fn2: string;
  fCreationDT: TDateTime;
begin
  id := DTData.tblDT.RecordCount + 1;
  fn2 := ExtractFileName(fn); // includes file extension
  // Get the creation time of the specified file
  fCreationDT := TFile.GetCreationTime(fn);
  // Filename used can show session, event. (After correct DT setup).
  // fGUID is unique string(do3)/number(do4) given to each file by DT.
  if DolphinTimingFileType = 1 then
    ExtractFileNameFieldsDO4(fn2, fSessionNum, fEventNum, fHeatNum, fGender,
      fGUID)
  else
    ExtractFileNameFieldsDO3(fn2, fSessionNum, fEventNum, fGUID);

  // write out DTData.tblDT record
  // CREATE NEW RECORD - one for each lane.
  DTData.tblDT.Append;
  DTData.tblDT.FieldByName('DTID').ASInteger := id;
  // FILENAME = INFORMATION (prefix f)  common
  DTData.tblDT.fieldbyName('CreatedDT').AsDateTime := fCreationDT;
  DTData.tblDT.fieldbyName('FileName').AsString := fn2; // include file ext.
  DTData.tblDT.fieldbyName('fSession').AsInteger := fSessionNum;
  DTData.tblDT.fieldbyName('fEvent').AsInteger := fEventNum;
  if DolphinTimingFileType = 1 then
  begin
    DTData.tblDT.fieldbyName('fHeat').AsInteger:= fHeatNum; // DO4 only.
    DTData.tblDT.fieldbyName('fGender').AsString := fGender; // DO4 only.
  end;

  DTData.tblDT.fieldbyName('fGUID').AsString := fGUID;
  // FINALIZE - POST NEW RECORD.
  DTData.tblDT.Post;
  GetDTHeat(fn, id);
end;

function GetFileCreationTime(const FileName: string): TDateTime;
var
  Handle: THandle;
  FindData: TWin32FindData;
  SystemTime: TSystemTime;
  LocalFileTime: TFileTime;
begin
  Handle := FindFirstFile(PChar(FileName), FindData);
  if Handle <> INVALID_HANDLE_VALUE then
  begin
    Windows.FindClose(Handle);
    // Convert file time to local file time
    if FileTimeToLocalFileTime(FindData.ftCreationTime, LocalFileTime) then
    begin
      // Convert file time to system time
      if FileTimeToSystemTime(LocalFileTime, SystemTime) then
      begin
        // Convert system time to TDateTime
        Result := SystemTimeToDateTime(SystemTime);
        Exit;
      end;
    end;
  end;
  // Return 0 if there is an error
  Result := 0;
end;

procedure ExtractHeader(const InputStr: string; var Session: integer;
  var Event: integer; var Heat: integer; var Gender: string);
var
  Fields: TArray<string>;
begin
  // Split string by the ';' character
  // example 0;0;1;A  (DO3)
  // example 1;1;1;A (DO4)
  Fields := SplitString(InputStr, ';');
  if Length(Fields) <> 4 then
    raise Exception.Create('Invalid format');
  Session := StrToInt(Fields[0]);
  Event := StrToInt(Fields[1]);
  Heat := StrToInt(Fields[2]);
  Gender := Fields[3];
end;

function StrToCustomTime(const TimeStr: string): TTime;
var
  Seconds, Hundredths: integer;
  DotPos: integer;
  TimeValue: Double;
begin
  // Handle empty string (no time provided)
  if TimeStr = '' then
    Exit(0);

  // Find the position of the dot
  DotPos := Pos('.', TimeStr);

  if DotPos > 0 then
  begin
    // Convert the part before the dot (seconds)
    Seconds := StrToInt(Copy(TimeStr, 1, DotPos - 1));

    // Convert the part after the dot (hundredths)
    Hundredths := StrToInt(Copy(TimeStr, DotPos + 1, Length(TimeStr) - DotPos));

    // Calculate the time as a fraction of a day (TTime uses days)
    TimeValue := (Seconds + (Hundredths / 100)) / SecsPerDay;
    // SecsPerDay is 86400 (seconds in a day)
  end
  else
  begin
    // If there's no dot, treat the string as whole seconds
    Seconds := StrToInt(TimeStr);
    TimeValue := Seconds / SecsPerDay;
  end;

  Result := TimeValue;
end;

procedure ExtractSplits(const InputStr: string;
  ASplits: array of TTime; StartIndex: Integer);
var
  Fields: TArray<string>;
  i: Integer;
begin

{
Number of Splits – (1-10) Enter 1 to use the first time as the final time. A single length
race would have only one split (i.e. the final time), and multi length races would have
one split for every lap.
o Example 1: A 25 yard race in a 25 yard pool would have a split count of 1
meaning only on one time is collected (i.e. the final time)
o Example 2: A 100 meter race in a 50 meter pool would also have a split count
of 1 (i.e: the final time of the single lap.)
o Example 3: A 200 yard race in a 25 yard pool would have a split count of 4.
}

  // Split string by the ';' character
  Fields := InputStr.Split([';']);

  for i := 0 to High(ASplits) do
  begin
    if Length(Fields) > StartIndex + i then
      ASplits[i] := StrToCustomTime(Fields[StartIndex + i])
    else
      ASplits[i] := 0; // Assign default value if out of bounds
  end;
end;

procedure ExtractLane(const InputStr: string;
  var lane: integer);
var
  Fields: TArray<string>;
begin
  // Split string by the ';' character
  Fields := SplitString(InputStr, ';');
  if Length(Fields) = 0 then
    raise Exception.Create('Invalid format');
  // Extract the lane as an integer
  lane := StrToInt(Fields[0]);
end;

procedure ExtractTimeKeepers(const InputStr: string;
  ATimeKeepers: array of TTime; StartIndex: Integer);
var
  Fields: TArray<string>;
  i: integer;
begin
  // Split string by the ';' character
  Fields := SplitString(InputStr, ';');

  for i := 0 to High(ATimeKeepers) do
  begin
    if Length(Fields) > StartIndex + i then
      ATimeKeepers[i] := StrToCustomTime(Fields[StartIndex + i])
    else
      ATimeKeepers[i] := 0; // Assign default value if out of bounds
  end;
end;

procedure ExtractFileNameFieldsDO3(const InputStr: string; var Session: integer;
  var Event: integer; var GUID: string);
var
  Fields: TArray<string>;
begin
  // Split string by the '-' character
  Fields := SplitString(InputStr, '-');
  if Length(Fields) <> 3 then
    raise Exception.Create('Invalid format');
  // Extract the first and second fields as integers
  Session := StrToInt(Fields[0]);
  Event := StrToInt(Fields[1]);
  // The third field has a '.' delimiter for the string and the '.do3' part
  GUID := Copy(Fields[2], 1, Pos('.', Fields[2]) - 1);
  // Check the '.do3' part
  {
    if Fields[2].Substring(Pos('.', Fields[2])) = '.do3' then
    FinalFieldInt := 1
    else
    raise Exception.Create('Invalid final part');
  }
end;

procedure ExtractFileNameFieldsDO4(const InputStr: string; var Session: integer;
  var Event: integer; var Heat: integer; var Gender: string; var RaceID: string);
var
  Fields: TArray<string>;
  s: string;
begin
  // Split string by the '-' character
  Fields := SplitString(InputStr, '-');
  if Length(Fields) <> 4 then
    raise Exception.Create('Invalid format');
  // Extract the first and second fields as integers
  Session := StrToInt(Fields[0]);
  Event := StrToInt(Fields[1]);
  // The third field has A or B or X appended at end of string.
  // Copy uses one-based array indexing.
  // A = boys, B = girls, X = mixed gender...
  Gender := RightStr(Fields[2], 1);
  if (Gender <> 'A') and (Gender <> 'B') then Gender := 'X';
  s := Copy(Fields[2], 1, Length(Fields[2]) - 1);
  Heat := StrToIntDef(s, 0);
  // The fourthfield has a '.' delimiter for the string and the '.do4' part
  RaceID := Copy(Fields[3], 1, Pos('.', Fields[3]) - 1);
  // Alternatively :: RaceID := SplitString(Fields[3], '.')[0];
end;

function ExtractSessionField(const InputStr: string): integer;
var
  Fields: TArray<string>;
begin
  result := 0;
  // Split string by the '-' character
  Fields := SplitString(InputStr, '-');
  if Length(Fields) > 1 then
  try
    // Extract the first field - SessionID
    result := StrToInt(Fields[0]);
  except on E: Exception do
    result := 0;
  end;
end;

procedure ProcessDO4Files(const ADirectory: string; pBar: TProgressBar; SessionID: integer = 0);
var
  LList: TStringDynArray;
  LSearchOption: TSearchOption;
  fileMask: string;
  I, ID: integer;
begin
  fileMask := '*.DO4';
  DolphinTimingFileType := 1;
  if Assigned(pBar) then pBar.Position := 0;
  { Select the search option }
  // do not do recursive extract into subfolders
  LSearchOption := TSearchOption.soTopDirectoryOnly;
  try
    { For files use GetFiles method }
    LList := TDirectory.GetFiles(ADirectory, fileMask, LSearchOption);
    { Extract DATA and Populate the memory table. }
    for I := 0 to Length(LList) - 1 do
    begin
      if (SessionID = 0) then
        GetDT(LList[I])
      else
      begin
        ID := ExtractSessionField(LList[I]);
        if (ID = SessionID) then
          GetDT(LList[I]);
      end;
      // update progress
      pBar.Position := Trunc(Ceil(i / (Length(LList) - 1)) * 100);
      pBar.RePaint;
    end;
  except
    { Catch the possible exceptions }
    MessageBox(0, PChar('Incorrect path or search mask'),
      PChar('Extract Dolphin .DO4 Files'), MB_ICONERROR or MB_OK);
  end;

end;

procedure ProcessDO3Files(const ADirectory: string; pBar: TProgressBar; SessionID: integer = 0);
var
  LList: TStringDynArray;
  LSearchOption: TSearchOption;
  fileMask: string;
  I, ID: integer;
begin
  fileMask := '*.DO3';
  DolphinTimingFileType := 0;

  if Assigned(pBar) then pBar.Position := 0;
  { Select the search option }
  // do not do recursive extract into subfolders
  LSearchOption := TSearchOption.soTopDirectoryOnly;

  try
    { For files use GetFiles method }
    LList := TDirectory.GetFiles(ADirectory, fileMask, LSearchOption);
    { Extract DATA and Populate the memory table. }
    for I := 0 to Length(LList) - 1 do
    begin
      if (SessionID = 0) then
        GetDT(LList[I])
      else
      begin
        ID := ExtractSessionField(LList[I]);
        if (ID = SessionID) then
          GetDT(LList[I]);
      end;
      // update progress
      pBar.Position := Trunc(Ceil(i / (Length(LList) - 1)) * 100);
      pBar.RePaint;
    end;
  except
    { Catch the possible exceptions }
    MessageBox(0, PChar('Incorrect path or search mask'),
      PChar('Extract Dolphin .DO3 Files'), MB_ICONERROR or MB_OK);
  end;


end;

procedure PrepareDTData();
begin
  // clear all data records ....
  DTData.tblDT.EmptyDataSet;
  DTData.tblDTHeat.EmptyDataSet;
  DTData.tblDTLane.EmptyDataSet;
  DTData.tblDTNoodle.EmptyDataSet;

  // Detach from Master Detail ...
  DTData.tblDTHeat.MasterSource := nil;
  DTData.tblDTLane.MasterSource := nil;
  DTData.tblDTNoodle.MasterSource := nil;

  // re-establish Master Detail ...
  DTData.tblDTHeat.MasterSource := DTData.dsDT;
  DTData.tblDTLane.MasterSource := DTData.dsDTHeat;
  DTData.tblDTNoodle.MasterSource := DTData.dsDTLane;
end;

Procedure PopulateDTData(const ADirectory: string; pBar: TProgressBar);
begin
  DTData.tblDT.DisableControls;
  DTData.tblDTHeat.DisableControls;
  DTData.tblDTLane.DisableControls;
  DTData.tblDTNoodle.DisableControls;

  if Assigned(pBar) then pBar.Position := 0;

  ProcessDO3Files(ADirectory, pBar); // assigns filetype 0
  ProcessDO4Files(ADirectory, pBar); // assigns filetype 1

  DTData.tblDT.First;

  DTData.tblDT.EnableControls;
  DTData.tblDTHeat.EnableControls;
  DTData.tblDTLane.EnableControls;
  DTData.tblDTNoodle.EnableControls;

  end;

function GetDTFileType(const ADirectory: string): integer;
var
  LList: TStringDynArray;
  LSearchOption: TSearchOption;
  fileMask: string;
  I: integer;
  foundDO3, foundDO4: boolean;
begin
  fileMask := '*.DO?';
  foundDO3 := false;
  foundDO4 := false;
  result := -1;
  // do not do recursive extract into subfolders
  LSearchOption := TSearchOption.soTopDirectoryOnly;
  try
    { For files use GetFiles method }
    LList := TDirectory.GetFiles(ADirectory, fileMask, LSearchOption);
    { Extract DATA and Populate the memory table. }
    for I := 0 to Length(LList) - 1 do
    begin
      if LList[I].Contains('.DO3') then
        foundDO3 := true;
      if LList[I].Contains('.DO4') then
        foundDO4 := true;
    end;
  except
    { Catch the possible exceptions }
    MessageBox(0, PChar('Incorrect path or search mask'),
      PChar('Get file type of directory...'), MB_ICONERROR or MB_OK);
    exit;
  end;
  if foundDO3 and not foundDO4 then
    result := 0
  else if foundDO4 and not foundDO3 then
    result := 1
  else if foundDO4 and foundDO3 then
    result := 2;

end;




end.

