unit dtUtils;

interface

uses dmDTData, vcl.ComCtrls, Math, System.Types, System.IOUtils,
  SysUtils, Windows, StrUtils, System.Classes, SCMDefines;

type TdtUtils = record
    private
      type
        PTime = ^TTime;
      var
        Splits: array[0..9] of TTime;
        TimeKeepers: array[0..2] of TTime;

      procedure ExtractHeader(const InputStr:
        string; var Session: integer;
        var Event: integer;
        var Heat: integer;
        var Gender: string);
      procedure ExtractLane(const InputStr: string;  var lane: integer);
      procedure ExtractTimeKeepers(const InputStr: string;
        ATimeKeepers: array of TTime; StartIndex: Integer);
      procedure ExtractSplits(const InputStr: string;
        ASplits: array of TTime; StartIndex: Integer);
    public
      procedure ExtractFileNameFieldsDO3(const InputStr: string;
        var Session: integer;
        var Event: integer;
        var GUID: string);
      procedure ExtractFileNameFieldsDO4(const InputStr: string;
        var Session: integer;
        var Event: integer;
        var Heat: integer;
        var Gender:
        string; var
        RaceID: string);

    private
      function StrToCustomTime(const TimeStr: string): TTime;
      function ExtractSessionField(const InputStr: string): integer;

      procedure GetDTSession(fn: string; DolphinTimingFileType: dtFileType);
      procedure GetDTEvent(fn: string; SessionID: integer);
      procedure GetDTHeat(fn: string; EventID: integer);
      procedure GetDTINDIV(sl: TStringList; DTHeatID: integer);
      procedure GetDTTEAM(sl: TStringList; DTHeatID: integer);
      function GetFileCreationTime(const FileName: string): TDateTime;

      procedure ProcessDO4Files(const ADirectory: string;
        pBar: TProgressBar;
        SessionID: integer = 0);

      procedure ProcessDO3Files(const ADirectory: string;
        pBar: TProgressBar;
        SessionID: integer = 0);

    public

      procedure PrepareDTData();
      procedure PopulateDTData(const ADirectory: string; pBar: TProgressBar);
      procedure AppendDTData(const AFileName:string);
      // procedure CalculateDeviation(INDIV_TEAM_ID: integer; AEventType: scmEventType);
      function GetDTFileType(const ADirectory: string): dtFileType;
      function GetDTFileTypeOfFile(const AFileName: string): dtFileType;

//      class operator Initialize (out Dest: TdtUtils);
//      class operator Finalize (var Dest: TdtUtils);

end;


// ---------------------------------------------------

{
This is a CSV file and can be hand typed or generated by meet management software.
Each line of this file should be formatted as follows:
Event Number,EventName,Number of Heats,Number of Splits,Round.
Example:
  1A,Boys 50 M Free,4,1,P
  1B,Girls 50 M Free,5,1,P
  2A,Boys 100 M Breaststroke,2,2,P
  2B,Girls 100 M Breaststroke,2,2,P
...
}

implementation

procedure TdtUtils.AppendDTData(const AFileName:string);
Begin
  // todo
End;

procedure TdtUtils.GetDTINDIV(sl: TStringList; DTHeatID: integer);
var
  id, I, j, lane: integer;
  TimeFieldName, TimeModeFieldName,  TimeModeFieldNameErr, SplitFieldName: string;
begin
  // A record for each lane.
  // Ignore first (header) and last line (checkSum).
  for I := 1 to (sl.Count - 2) do
  begin
    id := DTData.tblDTINDV.RecordCount + 1;
    DTData.tblDTINDV.Append;

    ExtractLane(sl[I], lane);
    ExtractTimeKeepers(sl[I], TimeKeepers, 1);
    ExtractSplits(sl[I], Splits, 4);

    DTData.tblDTINDV.fieldbyName('INDVID').AsInteger := id; // primary key
    DTData.tblDTINDV.fieldbyName('HeatID').AsInteger := DTHeatID; // master.detail.
    DTData.tblDTINDV.fieldbyName('Lane').AsInteger := lane;

    for j := 0 to High(TimeKeepers) do
    begin
      // Generate field names
      TimeFieldName := Format('Time%d', [j + 1]);
      TimeModeFieldName := Format('Time%d', [j + 1]) + 'Mode';
      TimeModeFieldName := Format('Time%d', [j + 1]) + 'Err';
      // Set race-time and use flag based on TimeKeepers value
      if TimeKeepers[j] > 0 then
      begin
        DTData.tblDTINDV.FieldByName(TimeFieldName).AsDateTime := TDateTime(TimeKeepers[j]);
        DTData.tblDTINDV.FieldByName(TimeModeFieldName).AsInteger := Ord(tmAutoEnabled);
        DTData.tblDTINDV.FieldByName(TimeModeFieldNameErr).Clear;
      end
      else
      begin
        DTData.tblDTINDV.FieldByName(TimeFieldName).Clear;
        DTData.tblDTINDV.FieldByName(TimeModeFieldName).AsInteger := Ord(tmAutoDisabled);
        DTData.tblDTINDV.FieldByName(TimeModeFieldNameErr).AsInteger := Ord(tmeEmpty);
      end;
    end;

    // Calculate deviation for each timekeeper?

    DTData.tblDTINDV.fieldbyName('imgPatch').AsInteger := 0;
    DTData.tblDTINDV.fieldbyName('AutoTime').AsBoolean := true;

    for j := 0 to High(Splits) do
    begin
      // Generate field names
      SplitFieldName := Format('Split%d', [j + 1]);
      if Splits[j] > 0 then
        DTData.tblDTINDV.fieldbyName(SplitFieldName).AsDateTime := TDateTime(Splits[j])
       else
        DTData.tblDTINDV.FieldByName(SplitFieldName).Clear;
    end;

    DTData.tblDTINDV.Post;
  end;

end;

procedure TdtUtils.GetDTTEAM(sl: TStringList; DTHeatID: integer);
begin
{TODO -oBSA -cGeneral : ActionItem}
end;

procedure TdtUtils.GetDTEvent(fn: string; SessionID: integer);
var
  sl: TStringList;
  SessionNum, EventNum, HeatNum, id, AGenderID: integer;
  GenderStr, checksum, s, s2: string;
begin
  // read header and lane information (Racetimes x3).
  sl := TStringList.Create();
  sl.LoadFromFile(fn);
  if not sl.IsEmpty then
  begin
    // first line represents SessionNum, EventNum, HeatNum, GenderStr (A,B,X)
    // delimeter is ';'
    ExtractHeader(sl[0], SessionNum, EventNum, HeatNum, GenderStr);
    // checksum is the last line
    checksum := sl[sl.Count - 1];
    // calculate the IDENTIFIER.
    id := DTData.tblDTEvent.RecordCount + 1;
    // NEW RECORD.
    DTData.tblDTEvent.Append;
    DTData.tblDTEvent.fieldbyName('EventID').AsInteger := id; // PK
    DTData.tblDTEvent.fieldbyName('SessionID').AsInteger := SessionID; // master - detail.
    // HEADER - first line of text - common
    DTData.tblDTEvent.fieldbyName('EventNum').AsInteger := EventNum;
    DTData.tblDTEvent.fieldbyName('GenderStr').AsString := GenderStr;
    if (GenderStr = 'A') then
      begin
      DTData.tblDTEvent.fieldbyName('GenderID').AsInteger := 1;
      s2 := 'Boys';
      end
    else if (GenderStr = 'B') then
    begin
      DTData.tblDTEvent.fieldbyName('GenderID').AsInteger := 2;
      s2 := 'Girls';
    end
    else
    begin
      DTData.tblDTEvent.fieldbyName('GenderID').Clear;
      s2 := 'Mixed genders.';
    end;
    s := 'SessionID: ' + IntToStr(SessionNum) + ' Event Number: ' + IntToStr(EventNum) +
      ' - ' + s2;

    DTData.tblDTEvent.fieldbyName('Caption').AsString := s;

    DTData.tblDTEvent.Post;
    // LANES + TIMEKEEPERS 1-3 + SPLITS (upto 10).
    GetDTHeat(fn, id);
  end;
  sl.free;
end;

procedure TdtUtils.GetDTHeat(fn: string; EventID: integer);
var
  sl: TStringList;
  SessionNum, EventNum, HeatNum, id: integer;
  Gender, checksum: string;
begin
  // read header and lane information (Racetimes x3).
  sl := TStringList.Create();
  sl.LoadFromFile(fn);
  if not sl.IsEmpty then
  begin
    // first line represents SessionNum, EventNum, HeatNum, gender (A,B,X)
    // delimeter is ';'
    ExtractHeader(sl[0], SessionNum, EventNum, HeatNum, Gender);
    // checksum is the last line
    checksum := sl[sl.Count - 1];
    // calculate the IDENTIFIER.
    id := DTData.tblDTHeat.RecordCount + 1;
    // NEW RECORD.
    DTData.tblDTHeat.Append;
    DTData.tblDTHeat.fieldbyName('HeatID').AsInteger := id; // PK
    DTData.tblDTHeat.fieldbyName('EventID').AsInteger := EventID; // master - detail.
    // HEADER - first line of text - common
    DTData.tblDTHeat.fieldbyName('HeatNum').AsInteger := HeatNum;
    DTData.tblDTHeat.fieldbyName('Caption').AsString := 'Heat Number: ' + IntToStr(HeatNum);
    // CHECKSUM - last line of text - common
    DTData.tblDTHeat.fieldbyName('CheckSum').AsString := checksum;
    DTData.tblDTHeat.Post;
    // LANES + TIMEKEEPERS 1-3 + SPLITS (upto 10).
    // if scmEventType = etINDV
    GetDTINDIV(sl, id);
    // else
    // GetDTTEAM(sl, id);
  end;
  sl.free;
end;

procedure TdtUtils.GetDTSession(fn: string; DolphinTimingFileType: dtFileType);
var
  id, SessionNum, EventNum, HeatNum: integer;
  AGUID, Gender: string;
  s, fn2, aPath: string;
  fCreationDT: TDateTime;
  fs: TFormatSettings;
begin
  id := DTData.tblDTSession.RecordCount + 1;
  fn2 := ExtractFileName(fn); // includes file extension
  aPath := ExtractFilePath(fn);
  // Get the creation time of the specified file
  fCreationDT := TFile.GetCreationTime(fn);
  // Filename used can show session, event. (After correct DT setup).
  // AGUID is unique string(do3)/number(do4) given to each file by DT.
  if DolphinTimingFileType = dtDO4 then
    ExtractFileNameFieldsDO4(fn2, SessionNum, EventNum, HeatNum, Gender,
      AGUID)
  else
    ExtractFileNameFieldsDO3(fn2, SessionNum, EventNum, AGUID);

  // write out DTData.tblDT record
  // CREATE NEW RECORD - one for each lane.
  DTData.tblDTSession.Append;
  DTData.tblDTSession.FieldByName('DTID').ASInteger := id;
  // FILENAME = INFORMATION (prefix f)  common
  DTData.tblDTSession.fieldbyName('CreatedDT').AsDateTime := Now;
  DTData.tblDTSession.fieldbyName('FileName').AsString := fn2; // include file ext.
  DTData.tblDTSession.fieldbyName('Path').AsString := aPath; // include file ext.
  DTData.tblDTSession.fieldbyName('SessionID').AsInteger := SessionNum;
  DTData.tblDTSession.fieldbyName('SessionStart').AsDateTime := fCreationDT;

  fs := TFormatSettings.Create;
  fs.DateSeparator := '_';
  s := 'SessionID: ' + IntToStr(SessionNum) + ' Date: ' + DatetoStr(fCreationDT, fs);

  DTData.tblDTSession.fieldbyName('Caption').AsString := s;
  DTData.tblDTSession.fieldbyName('GUIDstr').AsString := AGUID;
  if DolphinTimingFileType = dtDO4 then
    DTData.tblDTSession.fieldbyName('GUID').AsInteger:= StrToIntDef(AGUID, 0);

  // FINALIZE - POST NEW RECORD.
  DTData.tblDTSession.Post;
  GetDTHeat(fn, id);
end;

function TdtUtils.GetFileCreationTime(const FileName: string): TDateTime;
var
  Handle: THandle;
  FindData: TWin32FindData;
  SystemTime: TSystemTime;
  LocalFileTime: TFileTime;
begin
  Handle := FindFirstFile(PChar(FileName), FindData);
  if Handle <> INVALID_HANDLE_VALUE then
  begin
    Windows.FindClose(Handle);
    // Convert file time to local file time
    if FileTimeToLocalFileTime(FindData.ftCreationTime, LocalFileTime) then
    begin
      // Convert file time to system time
      if FileTimeToSystemTime(LocalFileTime, SystemTime) then
      begin
        // Convert system time to TDateTime
        Result := SystemTimeToDateTime(SystemTime);
        Exit;
      end;
    end;
  end;
  // Return 0 if there is an error
  Result := 0;
end;

procedure TdtUtils.ExtractHeader(const InputStr: string; var Session: integer;
  var Event: integer; var Heat: integer; var Gender: string);
var
  Fields: TArray<string>;
begin
  // Split string by the ';' character
  // example 0;0;1;A  (DO3)
  // example 1;1;1;A (DO4)
  Session := 0;
  Event := 0;
  Heat := 0;
  Gender := 'X';

  Fields := SplitString(InputStr, ';');
  if Length(Fields) <> 4 then exit;   // return default assignment.
  Session := StrToIntDef(Fields[0], 0);
  Event := StrToIntDef(Fields[1], 0);
  Heat := StrToIntDef(Fields[2], 0);
  Gender := Fields[3];
end;

function TdtUtils.StrToCustomTime(const TimeStr: string): TTime;
var
  Seconds, Hundredths: integer;
  DotPos: integer;
  TimeValue: Double;
begin
  // Handle empty string (no time provided)
  if TimeStr = '' then
    Exit(0);

  // Find the position of the dot
  DotPos := Pos('.', TimeStr);

  if DotPos > 0 then
  begin
    // Convert the part before the dot (seconds)
    Seconds := StrToInt(Copy(TimeStr, 1, DotPos - 1));

    // Convert the part after the dot (hundredths)
    Hundredths := StrToInt(Copy(TimeStr, DotPos + 1, Length(TimeStr) - DotPos));

    // Calculate the time as a fraction of a day (TTime uses days)
    TimeValue := (Seconds + (Hundredths / 100)) / SecsPerDay;
    // SecsPerDay is 86400 (seconds in a day)
  end
  else
  begin
    // If there's no dot, treat the string as whole seconds
    Seconds := StrToInt(TimeStr);
    TimeValue := Seconds / SecsPerDay;
  end;

  Result := TimeValue;
end;

procedure TdtUtils.ExtractSplits(const InputStr: string;
  ASplits: array of TTime; StartIndex: Integer);
var
  Fields: TArray<string>;
  i: Integer;
begin

{
Number of Splits – (1-10) Enter 1 to use the first time as the final time. A single length
race would have only one split (i.e. the final time), and multi length races would have
one split for every lap.
o Example 1: A 25 yard race in a 25 yard pool would have a split count of 1
meaning only on one time is collected (i.e. the final time)
o Example 2: A 100 meter race in a 50 meter pool would also have a split count
of 1 (i.e: the final time of the single lap.)
o Example 3: A 200 yard race in a 25 yard pool would have a split count of 4.
}

  // Split string by the ';' character
  Fields := InputStr.Split([';']);

  for i := 0 to High(ASplits) do
  begin
    if Length(Fields) > StartIndex + i then
      ASplits[i] := StrToCustomTime(Fields[StartIndex + i])
    else
      ASplits[i] := 0; // Assign default value if out of bounds
  end;
end;

procedure TdtUtils.ExtractLane(const InputStr: string;
  var lane: integer);
var
  Fields: TArray<string>;
  s, s2: string;
  i: integer;
begin
  lane := 0;
  // Split string by the ';' character
  Fields := SplitString(InputStr, ';');
  if Length(Fields) = 0 then exit;
  // Alternatively - raise Exception.Create('Invalid format');

  s := '';
  s2 := Fields[0]; // lane number. eg. 'Lane1' (DO4), '1' (DO3).
  // strip out non-numeric characters
  for i := 1 to Length(s2) do
    if s2[i] in ['0'..'9'] then
      s := s + s2[i];

  lane := StrToIntDef(s, 0); // Extract the lane as an integer

end;


procedure TdtUtils.ExtractTimeKeepers(const InputStr: string;
  ATimeKeepers: array of TTime; StartIndex: Integer);
var
  Fields: TArray<string>;
  i: integer;
begin
  // Split string by the ';' character
  Fields := SplitString(InputStr, ';');
  // Fields[0] = lane number...
  for i := 0 to High(ATimeKeepers) do
  begin
    if Length(Fields) > StartIndex + i then
      ATimeKeepers[i] := StrToCustomTime(Fields[StartIndex + i])
    else
      ATimeKeepers[i] := 0; // Assign default value if out of bounds
  end;
end;

procedure TdtUtils.ExtractFileNameFieldsDO3(const InputStr: string; var Session: integer;
  var Event: integer; var GUID: string);
var
  Fields: TArray<string>;
  s: string;
begin
  Session := 0;
  Event := 0;

  if (Pos('\', InputStr) > 0) or (Pos('/', InputStr) > 0) then
    s := ExtractFileName(Inputstr);

  // Split string by the '-' character
  Fields := SplitString(InputStr, '-');
  if Length(Fields) <> 3 then
    exit;

  // Extract the first and second fields as integers
  Session := StrToIntDef(Fields[0], 0);
  Event := StrToIntDef(Fields[1], 0);
  // The third field has a '.' delimiter for the string and the '.do3' part
  GUID := Copy(Fields[2], 1, Pos('.', Fields[2]) - 1);

end;

procedure TdtUtils.ExtractFileNameFieldsDO4(const InputStr: string; var Session: integer;
  var Event: integer; var Heat: integer; var Gender: string; var RaceID: string);
var
  Fields: TArray<string>;
  s: string;
begin
  Session := 0;
  Event := 0;
  Heat := 0;
  Gender := 'X';
  RaceID := '';

  if (Pos('\', InputStr) > 0) or (Pos('/', InputStr) > 0) then
    s := ExtractFileName(Inputstr)
  else s := Inputstr;

  // Split string by the '-' character
  Fields := SplitString(s, '-');
  if Length(Fields) <> 4 then
    // just accept the default assignments.
    exit;

  Session := StrToIntDef(Fields[0], 0);
  Event := StrToIntDef(Fields[1], 0);

  // The third field has A or B or X appended at end of string.
  // Copy uses one-based array indexing.
  // A = boys, B = girls, X = mixed gender...
  Gender := RightStr(Fields[2], 1);
  if (Gender <> 'A') and (Gender <> 'B') then Gender := 'X';

  s := Copy(Fields[2], 1, Length(Fields[2]) - 1);
  Heat := StrToIntDef(s, 0);
  // The fourthfield has a '.' delimiter for the string and the '.do4' part
  RaceID := Copy(Fields[3], 1, Pos('.', Fields[3]) - 1);
  // Alternatively :: RaceID := SplitString(Fields[3], '.')[0];
end;

function TdtUtils.ExtractSessionField(const InputStr: string): integer;
var
  Fields: TArray<string>;
begin
  result := 0;
  // Split string by the '-' character
  Fields := SplitString(InputStr, '-');
  if Length(Fields) > 1 then
    // Extract the first field - SessionID
    result := StrToIntDef(Fields[0], 0);
end;

procedure TdtUtils.ProcessDO4Files(const ADirectory: string; pBar: TProgressBar; SessionID: integer = 0);
var
  LList: TStringDynArray;
  LSearchOption: TSearchOption;
  fileMask: string;
  I, ID: integer;
begin
  fileMask := '*.DO4';
  if Assigned(pBar) then pBar.Position := 0;
  { Select the search option }
  // do not do recursive extract into subfolders
  LSearchOption := TSearchOption.soTopDirectoryOnly;
  try
    { For files use GetFiles method }
    LList := TDirectory.GetFiles(ADirectory, fileMask, LSearchOption);
    { Extract DATA and Populate the memory table. }
    for I := 0 to Length(LList) - 1 do
    begin
      if (SessionID = 0) then
        GetDT(LList[I], dtDO4)
      else
      begin
        ID := ExtractSessionField(LList[I]);
        if (ID = SessionID) then
          GetDT(LList[I], dtDO4);
      end;
      // update progress
      pBar.Position := Trunc(Ceil(i / (Length(LList) - 1)) * 100);
      pBar.RePaint;
    end;
  except
    { Catch the possible exceptions }
    MessageBox(0, PChar('Incorrect path or search mask'),
      PChar('Extract Dolphin .DO4 Files'), MB_ICONERROR or MB_OK);
  end;

end;

procedure TdtUtils.ProcessDO3Files(const ADirectory: string; pBar: TProgressBar; SessionID: integer = 0);
var
  LList: TStringDynArray;
  LSearchOption: TSearchOption;
  fileMask: string;
  I, ID: integer;
begin
  fileMask := '*.DO3';

  if Assigned(pBar) then pBar.Position := 0;
  { Select the search option }
  // do not do recursive extract into subfolders
  LSearchOption := TSearchOption.soTopDirectoryOnly;

  try
    { For files use GetFiles method }
    LList := TDirectory.GetFiles(ADirectory, fileMask, LSearchOption);
    { Extract DATA and Populate the memory table. }
    for I := 0 to Length(LList) - 1 do
    begin
      if (SessionID = 0) then
        GetDT(LList[I], dtDO3)
      else
      begin
        ID := ExtractSessionField(LList[I]);
        if (ID = SessionID) then
          GetDT(LList[I], dtDO3);
      end;
      // update progress
      pBar.Position := Trunc(Ceil(i / (Length(LList) - 1)) * 100);
      pBar.RePaint;
    end;
  except
    { Catch the possible exceptions }
    MessageBox(0, PChar('Incorrect path or search mask'),
      PChar('Extract Dolphin .DO3 Files'), MB_ICONERROR or MB_OK);
  end;

end;

procedure TdtUtils.PrepareDTData();
begin
  // clear all data records ....
  DTData.tblDTSession.EmptyDataSet;
  DTData.tblDTHeat.EmptyDataSet;
  DTData.tblDTINDV.EmptyDataSet;
  DTData.tblDTNoodle.EmptyDataSet;

  // Detach from Master Detail ...
  DTData.tblDTHeat.MasterSource := nil;
  DTData.tblDTINDV.MasterSource := nil;
  DTData.tblDTNoodle.MasterSource := nil;

  // re-establish Master Detail ...
  DTData.tblDTHeat.MasterSource := DTData.dsDTSession;
  DTData.tblDTINDV.MasterSource := DTData.dsDTHeat;
  DTData.tblDTNoodle.MasterSource := DTData.dsDTINDV;
end;

Procedure TdtUtils.PopulateDTData(const ADirectory: string; pBar: TProgressBar);
var
dtFT: dtFileType;
begin
  DTData.tblDTSession.DisableControls;
  DTData.tblDTHeat.DisableControls;
  DTData.tblDTINDV.DisableControls;
  DTData.tblDTNoodle.DisableControls;

  if Assigned(pBar) then pBar.Position := 0;

  dtFT := GetDTFileType(ADirectory);
  case dtFT of
    dtUnknown:
      ; // no Dolphin Timing files in directory ...
    dtDO4:
      ProcessDO4Files(ADirectory, pBar);
    dtDO3:
      ProcessDO3Files(ADirectory, pBar);
    dtALL:
    begin
      ProcessDO3Files(ADirectory, pBar);
      ProcessDO4Files(ADirectory, pBar);
    end;
  end;

  DTData.tblDTSession.First;
  DTData.tblDTSession.EnableControls;
  DTData.tblDTHeat.EnableControls;
  DTData.tblDTINDV.EnableControls;
  DTData.tblDTNoodle.EnableControls;

  end;

function TdtUtils.GetDTFileType(const ADirectory: string): dtFileType;
var
  LList: TStringDynArray;
  LSearchOption: TSearchOption;
  fileMask: string;
  I: integer;
  foundDO3, foundDO4: boolean;
begin
  fileMask := '*.DO?';
  foundDO3 := false;
  foundDO4 := false;
  result := dtUnknown;
  // do not do recursive extract into subfolders
  LSearchOption := TSearchOption.soTopDirectoryOnly;
  try
    { For files use GetFiles method }
    LList := TDirectory.GetFiles(ADirectory, fileMask, LSearchOption);
    { Extract DATA and Populate the memory table. }
    for I := 0 to Length(LList) - 1 do
    begin
      if LList[I].Contains('.DO3') then
        foundDO3 := true;
      if LList[I].Contains('.DO4') then
        foundDO4 := true;
    end;
  except
    { Catch the possible exceptions }
    MessageBox(0, PChar('Incorrect path or search mask'),
      PChar('Get file type of directory...'), MB_ICONERROR or MB_OK);
    exit;
  end;
  if foundDO3 and not foundDO4 then
    result := dtALL
  else if foundDO4 and not foundDO3 then
    result := dtDO4
  else if foundDO4 and foundDO3 then
    result := dtDO3;
end;

function TdtUtils.GetDTFileTypeOfFile(const AFileName: string): dtFileType;
begin
  result := dtUnknown;
  if AfileName.Contains('.DO3') then
    result := dtDO3
  else if AfileName.Contains('.DO4') then
    result := dtDO4;
end;

end.

